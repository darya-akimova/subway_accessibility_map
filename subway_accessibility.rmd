---
title: "underserviced_areas"
author: "Darya Akimova"
date: "August 23, 2018"
output: 
  html_document:
    toc: true
    toc_float:
      smooth_scroll: false
    number_sections: true
    theme: flatly
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
```

Main question to address: What areas of NYC are under-serviced by ADA accessible stations?

Plan: Somehow randomly "sample" locations in the NYC territory in (longitude, latitude) unit pairs and then calculate distance from that point to the nearest ada-certified (accessible) subway station. Normalize to nearest (accessible or not accessible) station? 

Need:
- Data for which stations are ADA-accessible
- Data for station locations (longitude, latitude)
- Some way to sample the territory of NYC (it's an odd shape)

# Setup

## Packages

```{r packages, comment=NA}
#library(ggmap)
#library(cowplot)
#library(viridis)
#library(geosphere)
#library(rgdal)
#library(tmap)
library(tidyverse)
library(sf)
```

## Data

```{r data, comment=NA}
nyc.census.map <- st_read("./data/nyct2010_18a/nyct2010.shp")
subway.ent.exit <- read_csv("./data/2018_update/NYC_Transit_Subway_Entrance_And_Exit_Data.csv")
subway.by.line <- read_csv("./data/2018_update/nyc_subway_stations_grouped.csv")
```


```{r preview, comment=NA}
plot(nyc.census.map$geometry)
# subway entrances/exit data:
glimpse(subway.ent.exit)
# subway summary data
glimpse(subway.by.line)
```

First things first, cleanup the column names of the two subway info dataframes by converting the words to lower-case and by replacing empty spaces with `_`:

```{r comment=NA}
colnames(subway.ent.exit) <- colnames(subway.ent.exit) %>% 
  str_to_lower() %>% 
  str_replace(" ", "_")
colnames(subway.by.line) <- colnames(subway.by.line) %>% 
  str_to_lower() %>% 
  str_replace(" ", "_")
colnames(subway.ent.exit)
```

Much better! 

Now for some cleanup of the subway entrance/exit dataset:

* Create a unique station name column by combining the division. line, and station_name
* Gather the route names into one column and get rid of all of the missing values

```{r comment=NA}
# note that the sta
length(unique(subway.ent.exit$station_name))
nrow(subway.ent.exit %>% select(station_name, station_latitude:station_longitude) %>% distinct())
nrow(subway.ent.exit %>% select(division:station_name) %>% distinct())
sub.ext.sml <- subway.ent.exit %>% 
  unite("stat_name", division:station_name, sep = "_") %>% 
  select(stat_name:station_longitude, entrance_latitude:entrance_longitude, route1:route11, entrance_type:entry, ada) %>% 
  gather("route_num", "route_name", route1:route11) %>% 
  filter(!is.na(route_name)) %>% 
  select(-route_num)
glimpse(sub.ext.sml)
sapply(sub.ext.sml, anyNA)
```


```{r subway_boro}
set.seed(2018)
nyc311_loc <- read_csv(file = "./data/unique_nyc_2015_311.csv") %>%
  distinct() %>% 
  sample_frac(0.25, replace = FALSE)
glimpse(nyc311_loc)

sub.boro <- sub.ext.sml %>% 
  mutate(join_key = paste(round(station_latitude, 2), round(station_longitude, 2), sep = "_")) %>% 
  left_join(nyc311_loc %>% 
              mutate(latitude = round(Latitude, 2),
                     longitude = round(Longitude, 2),
                     join_key = paste(latitude, longitude, sep = "_")) %>% 
              distinct(), by = "join_key") %>% 
  # cleanup 
  select(stat_name:route_name, Borough) %>% 
  distinct() %>% 
  rename("borough" = Borough) %>% 
  mutate(borough = str_to_lower(borough))
glimpse(sub.boro)

ggplot(sub.boro, aes(station_longitude, station_latitude, color = borough)) +
  geom_point(size = 1, alpha = 0.5)

ggplot(sub.boro, aes(station_longitude, station_latitude, color = borough)) +
  geom_point(size = 1, alpha = 0.5) +
  facet_wrap(~borough, nrow = 2)

# some straight forward manual elimination: 
sub.boro %>% 
  filter(borough == "manhattan" & station_latitude < 40.7) %>% 
  ggplot(aes(station_longitude, station_latitude, color = borough)) +
  geom_point(size = 1, alpha = 0.5) +
  ylim(40.6, 40.9) +
  xlim(-74.05, -73.9)
sub.boro %>% 
  filter(borough == "bronx" & station_latitude < 40.8) %>% 
  ggplot(aes(station_longitude, station_latitude, color = borough)) +
  geom_point(size = 1, alpha = 0.5) +
  ylim(40.75, 40.91) +
  xlim(-73.93, -73.82)
sub.boro <- sub.boro %>% 
  filter(!((borough == "manhattan" & station_latitude < 40.7) | (borough == "bronx" & station_latitude < 40.8))) 

ggplot(sub.boro, aes(station_longitude, station_latitude, color = borough)) +
  geom_point(size = 1, alpha = 0.5)

sub.mult.boro <- sub.boro %>% 
  select(stat_name:station_longitude, borough) %>% 
  distinct() %>% 
  group_by(stat_name, station_latitude, station_longitude) %>% 
  count() %>% 
  filter(n > 1) %>% 
  arrange(stat_name)
glimpse(sub.mult.boro)

testing <- sub.boro %>% 
  select(stat_name:station_longitude, borough, route_name) %>% 
  distinct() %>% 
  group_by(stat_name, station_latitude, station_longitude, route_name) %>% 
  count() %>% 
  filter(n > 1) %>% 
  arrange(stat_name)
sub.mult.boro %>% anti_join(testing, by = "stat_name")
testing %>% anti_join(sub.mult.boro, by = "stat_name")

sub.test <- sub.boro %>% 
  filter(stat_name %in% sub.mult.boro$stat_name) %>% 
  select(stat_name:station_longitude, borough) %>% 
  distinct()
sub.test2 <- sub.boro %>% 
  filter(stat_name %in% sub.mult.boro$stat_name) %>% 
  select(stat_name:station_longitude, route_name, borough) %>% 
  arrange(stat_name, route_name, borough) %>% 
  distinct()

sub.boro <- sub.boro %>% 
  filter(
    !(
      (stat_name == "IND_6 Avenue_East Broadway" & borough == "brooklyn") | 
      (stat_name == "IND_63rd Street_Roosevelt Island" & borough == "queens") |
      (stat_name == "BMT_Broadway Jamaica_Crescent St" & borough == "queens") |
      (stat_name == "BMT_Broadway Jamaica_Cypress Hills" & borough == "queens") |
      (stat_name == "BMT_Broadway Jamaica_Elderts Lane-75th St" & borough == "brooklyn") |
      (stat_name == "IRT_Broadway-7th Ave_207th St" & borough == "bronx") |
      # techincally, this station is considred part of Manhattan, but it's not on Manhattan island itself
      (stat_name == "IRT_Broadway-7th Ave_Marble Hill-225th St" & borough == "manhattan") |
      (stat_name == "BMT_Canarsie_Halsey St" & borough == "brooklyn") |
      (stat_name == "BMT_Canarsie_Jefferson St" & borough == "queens") |
      (stat_name == "BMT_Canarsie_Myrtle Av" & borough == "queens") |
      (stat_name == "BMT_Canarsie_Wilson Av" & borough == "queens") |
      (stat_name == "IND_Crosstown_21st St" & borough == "brooklyn") |
      (stat_name == "IRT_Flushing_Hunters Point" & borough == "brooklyn") |
      (stat_name == "IRT_Flushing_Vernon Blvd-Jackson Av" & borough == "brooklyn") |
      (stat_name == "IND_Fulton_Euclid Av" & borough == "queens") |
      (stat_name == "IRT_Jerome_138th St" & borough == "manhattan") |
      (stat_name == "IRT_Jerome_149th St-Grand Concourse" & borough == "manhattan") |
      (stat_name == "IND_Liberty_80th St-Hudson St" & borough == "brooklyn") |
      (stat_name == "IND_Liberty_Grant Av" & borough == "queens") |
      (stat_name == "BMT_Myrtle_Forest Av" & borough == "brooklyn") |
      (stat_name == "BMT_Myrtle_Seneca Av" & borough == "brooklyn") |
      (stat_name == "IRT_Pelham_138th St-3rd Ave" & borough == "manhattan")
      )
    )
sub.boro %>% 
  select(stat_name:station_longitude, borough) %>% 
  distinct() %>% 
  group_by(stat_name, station_latitude, station_longitude) %>% 
  count() %>% 
  filter(n > 1) %>% 
  arrange(stat_name)

```




```{r dist_calc}
nyc.map.4boro <- nyc.census.map %>%  
  filter(BoroName != "Staten Island") %>% 
  mutate(BoroName = str_to_lower(BoroName))
tract.cent <- st_centroid(nyc.map.4boro)
plot(st_geometry(nyc.map.4boro), col = "grey", border = "white")
plot(tract.cent, pch = 16, cex = 0.25, col = "#D55E00", add = TRUE)



sub.small <- sample_n(sub.ext.sml, size = 20)
test <- st_as_sf(sub.small, coords = c("station_longitude", "station_latitude"), crs = 4326)
test2 <- st_transform(test, crs = st_crs(nyc.map.4boro))
plot(st_geometry(nyc.map.4boro), col = "grey", border = "white")
plot(test2, pch = 16, cex = 1, col = "#D55E00", add = TRUE)

cent.stat.geo <- st_transform(tract.cent, crs = st_crs(test))
(st_distance(test, cent.stat.geo))


test2$BoroName <- "Manhattan"
test3 <- st_transform(tract.cent, crs = st_crs(test))
test4 <- unclass(test3$geometry)

tract.cent %>% 
  filter(BoroName == "manhattan") %>% 
  st_distance(test2) %>% 
  unclass() %>% 
  as_tibble()

ggplot(nyc.map.4boro) +
  geom_sf() 

```











Mucking around, trying to see what I have to work with.

```{r looking_over_data, comment=NA, eval=FALSE}
# What are the cols and how many missing values per col?
subloc_raw <- subloc_raw %>% 
  replace_na(
    list(
      route1 = "", route2 = "", route3 = "", route4 = "", 
      route5 = "", route6 = "", route7 = "", route8 = "", 
      route9 = "", route10 = "", route11 = ""
      )
    ) %>% 
  unite(col = routes, route1:route11, sep = "")
subloc_raw %>% 
  is.na %>% 
  as.data.frame() %>% 
  sapply(sum)
ada_raw %>% 
  is.na %>% 
  as.data.frame() %>% 
  sapply(sum)
# would help future steps to assign a borough to each station - can the ada_raw data be used? 
subloc_raw %>% 
  select(line:station_longitude) %>% 
  distinct() %>% 
  anti_join(ada_raw, by = c("station_name" = "station"))
# not many station names match across the two datasets - would take some time to untangle - is there another way?
test <- subloc_raw %>% 
  select(line:station_longitude) %>% 
  distinct() %>% 
  mutate(join_key = paste(round(station_latitude, 2), round(station_longitude, 2), sep = "_")) %>% 
  left_join(nyc311_loc %>% 
              mutate(latitude = round(latitude, 2),
                     longitude = round(longitude, 2),
                     join_key = paste(latitude, longitude, sep = "_")) %>% 
              distinct(), by = "join_key")
# all of the stations can be assigned a location based on the rounded NYC 311 dataset!
subloc_bor <- subloc_raw %>% 
  mutate(join_key = paste(round(station_latitude, 2), round(station_longitude, 2), sep = "_")) %>% 
  left_join(nyc311_loc %>% 
              mutate(latitude = round(latitude, 2),
                     longitude = round(longitude, 2),
                     join_key = paste(latitude, longitude, sep = "_")) %>% 
              distinct(), by = "join_key") %>% 
  # cleanup 
  select(-join_key, -latitude, -longitude) %>% 
  select(borough, everything())
glimpse(subloc_bor)

# after investigating, there are 27 extra rows - some of the nyc 311 locations are wrongly labeled


```

The Subway Entrance and Exit data seems to be good enough for an initial analysis. Hopefully the ADA column in that dataset is reliable. Need to compare this with the other datasets collected at some point, but joining is a problem.

To do:
- check against Wire Monkey's joined dataset
- figure out the station name inconsistencies?

For now, stick with the sub.location.raw.data for the rest of the analysis.

Map of all subway stations in this dataset:

```{r nyc_stations_map, fig.height=8, fig.width=8, comment=NA, eval=FALSE}
nyc_map <- get_map(location = "New York City")
ggmap(nyc_map) +
  geom_point(data = subloc_bor, aes(x = station_longitude, y = station_latitude, color = borough)) +
  ylim(40.495992, 40.915568) +  # NYC city limits latitude coordinates
  xlim(-74.257159, -73.699215) +  # NYC city limits longitude coordinates
  xlab("longitude") +
  ylab("latitude") +
  ggtitle("All NYC Subway Stations\nin the Subway Entrance/Exit Locations Data") +
  facet_wrap(~borough)

#subloc_bor %>% 
#  ggplot(aes(x = station_longitude, y = station_latitude, color = borough)) +
#  geom_point() +
#  ylim(40.495992, 40.915568) +  # NYC city limits latitude coordinates
#  xlim(-74.257159, -73.699215) +  # NYC city limits longitude coordinates
#  xlab("longitude") +
#  ylab("latitude") +
#  ggtitle("All NYC Subway Stations\nin the Subway Entrance/Exit Locations Data") +
#  facet_wrap(~borough)

# there's a couple of wrong assignments - try removing them:
subloc_bor <- subloc_bor %>% 
  filter(!(borough == "MANHATTAN" & station_latitude < 40.7)) %>%
  filter(!(borough == "BRONX" & station_latitude < 40.8))
ggmap(nyc_map) +
  geom_point(data = subloc_bor, aes(x = station_longitude, y = station_latitude, color = borough)) +
  ylim(40.495992, 40.915568) +  # NYC city limits latitude coordinates
  xlim(-74.257159, -73.699215) +  # NYC city limits longitude coordinates
  xlab("longitude") +
  ylab("latitude") +
  ggtitle("All NYC Subway Stations\nin the Subway Entrance/Exit Locations Data") +
  facet_wrap(~borough)
test <- subloc_bor %>% 
  filter(borough == "BRONX" & station_latitude < 40.8)
ggmap(nyc_map) +
  geom_point(data = test, aes(x = station_longitude, y = station_latitude)) +
  ylim(40.495992, 40.915568) +
  xlim(-74.257159, -73.699215)

odd <- subloc_bor %>% 
  select(borough:station_name) %>% 
  distinct() %>% 
  group_by(division, line, station_name) %>% 
  count() %>% 
  filter(n > 1) %>% 
  arrange(station_name)
test2 <- subloc_bor %>% 
  select(borough:station_longitude) %>% 
  distinct() %>% 
  filter(division %in% odd$division & station_name %in% odd$station_name & line %in% odd$line) %>% 
  arrange(station_latitude, station_longitude, borough)
# doesn't matter if the two annotations are QUEENS and BROOKLYN - will be treated together, but mixups that involve BRONX and MANHATTAN would be helpful to fix
test3 <- test2 %>% 
  filter(station_latitude > 40.70442) %>% 
  arrange(station_longitude, station_latitude, borough)
test3.brnx.man <- test3 %>% 
  filter(borough == "MANHATTAN" | borough == "BROND")
test4 <- test3 %>%
  filter(station_name %in% test3.brnx.man$station_name)
test4 %>% 
  select(division, line, station_name) %>% 
  distinct()
subloc_bor <- subloc_bor %>% 
  filter(!(division == "IND" & line == "6 Avenue" & station_name == "East Broadway" & borough == "BROOKLYN")) %>% 
  filter(!(division == "IRT" & line == "Jerome" & station_name == "149th St-Grand Concourse" & borough == "MANHATTAN")) %>% 
  filter(!(division == "IRT" & line == "Pelham" & station_name == "138th St-3rd Ave" & borough == "MANHATTAN")) %>% 
  filter(!(division == "IRT" & line == "Broadway-7th Ave" & station_name == "207th St" & borough == "BRONX")) 
# The F train Roosevelt Island stop is both Queens and Manhattan - leave it as such
# The Marble Hill - 225th St stop is also an odd station - leave as both Manhattan and Bronx
ggmap(nyc_map) +
  geom_point(data = subloc_bor, aes(x = station_longitude, y = station_latitude, color = borough)) +
  ylim(40.495992, 40.915568) +  # NYC city limits latitude coordinates
  xlim(-74.257159, -73.699215) +  # NYC city limits longitude coordinates
  xlab("longitude") +
  ylab("latitude") +
  ggtitle("All NYC Subway Stations\nin the Subway Entrance/Exit Locations Data") +
  facet_wrap(~borough)
```

Notes:
- No stations on Staten Island - will exclude Saten Island from this point on
- Most stations have more than one row (multiple entrances/exits) - need to compress info
- Station names in the station column are NOT unique (multiple 103rd St, etc) in the entrance/exit data, but station location may be a unique and consistent handle to grab all the entrances/exits associated with a station
- For now, will call any station that has at least one ADA-accessible entrance/exit "accessible", but we know that some stations are only partially accessible. For some station, different subway lines are serviced by different platforms within the same station, and not all platforms are fully accessible. This is where the elevator/escalator data joining may be useful. 

```{r ada_check, comment=NA, eval=FALSE}
# some info about entrances
subloc_bor %>% 
  ggplot(aes(x = entrance_type, fill = ada)) +
  geom_bar() +
  xlab("Entrance Type")
# same scale
subloc_bor %>% 
  ggplot(aes(x = entrance_type, fill = ada)) +
  geom_bar(position = "fill") +
  xlab("Entrance Type") +
  ylab("Proportion of Entrance that is ADA-Accessible")
```

According to the description of the variables in this dataset, `ADA == TRUE` indicates that the station is ADA-Accessible, but not necessarily if that entrance is

```{r, fig.height=8, fig.width=8, comment=NA, eval=FALSE}
ggmap(nyc_map) +
  geom_point(
    data = subloc_bor, 
    aes(x = station_longitude, y = station_latitude, color = ada),
    size = 1.5,
    alpha = 0.5) +
  ylim(40.55, 40.915568) +  # NYC city limits latitude coordinates
  xlim(-74.1, -73.699215) +  # NYC city limits longitude coordinates
  xlab("longitude") +
  ylab("latitude") +
  ggtitle("All NYC Subway Stations\nIn the Subway Entrance/Exit Locations Dataset\nColor by Accessibility")
# this data is missing the new Q-line information 
```

##Get (long,lat) pair locations from all over NYC

Now the next questions is how do I "sample" points from the area of NYC? 

I've worked a little bit with the NYC 311 call dataset before. Source: https://nycopendata.socrata.com/Social-Services/311-Service-Requests-from-2010-to-Present/erm2-nwe9

Remembered that it has latitude/longitude location info for the calls. Grabbed the locations from the 2015 NYC 311 calls data - use as random sample?

```{r nyc_locations, fig.height=8, fig.width=8, comment=NA, eval=FALSE}
nyc311_loc %>% 
  ggplot(aes(x = longitude, y = latitude)) +
  geom_bin2d(bins = 400) +
  coord_quickmap() +
  scale_fill_viridis() +
  ggtitle("Locations in the 2015 NYC 311 Calls Dataset")
```

Not bad. Empty areas are parks probably, should be okay to not include those.

```{r more_cleanup, comment=NA, eval=FALSE}
# create unique handle using station name, division, and line columns
subloc_bor <- subloc_bor %>% 
  mutate(station_id = paste(division, line, station_name, sep = " / ")) %>% 
  select(borough, station_id, everything())
subloc_sml <- subloc_bor %>% 
  select(station_id, borough:routes, ada) %>% 
  distinct()
glimpse(subloc_sml)
not.uni <- subloc_sml %>% 
  group_by(station_id) %>% 
  count() %>% 
  filter(n > 1)
subloc_sml_prob <- subloc_sml %>% 
  filter(station_id %in% not.uni$station_id) %>% 
  arrange(station_id)
# there's some dublicate stations still, must have had several station locations associated with those
subloc_sml <- subloc_sml %>% 
  group_by(station_id) %>% 
  mutate(avg_lat = mean(station_latitude)) %>% 
  mutate(avg_long = mean(station_longitude)) %>% 
  select(station_id:borough, avg_lat:avg_long, routes, ada) %>% 
  ungroup() %>% 
  distinct()
nrow(subloc_sml)
length(subloc_sml$station_id)
ggmap(nyc_map) +
  geom_point(data = subloc_sml, aes(x = avg_long, y = avg_lat, color = borough)) +
  ylim(40.495992, 40.915568) +  # NYC city limits latitude coordinates
  xlim(-74.257159, -73.699215) +  # NYC city limits longitude coordinates
  xlab("longitude") +
  ylab("latitude") +
  ggtitle("All NYC Subway Stations\nin the Subway Entrance/Exit Locations Data") +
  facet_wrap(~borough)
```

There's still some duplicates in the stations that have slightly different route assignments, but similar location. I'm going to leave them in for now, not sure what to do with them.

##Calculate distances between random location in NYC and the closest subway station

Small-scale test on a tiny portion of the subway stations and the 311 locations:

```{r small_scale_test, comment=NA, eval=FALSE}
# small scale test
# pick 10 locations in NYC and find the distance from that point to 5 stations in the city
loc_test <- nyc311_loc %>% 
  sample_n(10, replace = FALSE)
t1 <- rbind(subloc_sml$station_id, subloc_sml$station_id)
t2 <- as.data.frame(rbind(t1, t1, t1, t1, t1), stringsAsFactors = FALSE)
colnames(t2) <- paste("stat", 1:ncol(t2), sep = "")
t3 <- t2 %>% select(1:5)
t3

dist_test <- bind_cols(loc_test, t3) %>%
  gather(key = "station.num", value = "station_id", 4:8) %>% 
  arrange(station.num)
# each of the 10 (long,lat) points is now paired with each of the 5 stations selected
dist_test
# link the station.id to a (long,lat) pair for that station: 
dist_test_w_stat_loc <- dist_test %>% 
  inner_join(subloc_sml, by = "station_id")
# now calculate distance between point and the station using the geosphere package:
dist.test.res <- dist_test_w_stat_loc  %>% 
  mutate(
    dist.to.stat = distGeo(
      # p1 = NYC 311 location
      p1 = as.matrix(dist_test_w_stat_loc %>% select(longitude, latitude)), 
      # p2 = subway station location
      p2 = as.matrix(dist_test_w_stat_loc  %>% select(avg_long, avg_lat))
      ) * 0.000621371  # convert meters to miles
    ) %>% 
  mutate(loc.id = paste(borough.y, latitude, longitude, sep = " / "))
```

Note: the distances are based on direct distance from point to point

To do:
- Is there some way to incorporate Manhattan Distance into the calculation to get a more accurate distance measurement?  

What's the distance from the NYC 311 point to the closest station (out of the 5):

```{r, fig.height=8, fig.width=8, comment=NA, eval=FALSE}
dim(dist.test.res)
dist.test.nearest <- dist.test.res %>% 
  group_by(loc.id) %>% 
  summarize(nearest.stat = min(dist.to.stat)) %>% 
  ungroup() %>% 
  inner_join((dist.test.res %>% select(longitude, latitude, loc.id)), by = "loc.id") %>% 
  unique()
dim(dist.test.nearest)
ggmap(nyc_map) +
  geom_point(data = dist.test.nearest, aes(x = longitude, y = latitude, color = nearest.stat), size = 3) +
  scale_color_viridis(option = "B")  +
  ylim(40.55, 40.915568) +  # NYC city limits latitude coordinates
  xlim(-74.1, -73.699215) +  # NYC city limits longitude coordinates
  xlab("Longitude") +
  ylab("Latitude") +
  ggtitle("Direct distance to nearest subway station from point in NYC")
```

Test run with a small fraction of the data seems to have worked, now to tackle the full data.

##Full scale calculation for all points in the 311 calls dataset and all subway stations

###Run the following chunk at your own risk. R took up >40GB of RAM at some points for me.

(It's currently set to not evaluate)

I exported the distance to any nearest subway station to any point and the distance to the nearest ada subway station into csv files. They're imported in the next chunk.

```{r full_dist_calc, comment=NA, eval=FALSE}
glimpse(nyc311_loc)
glimpse(subloc_sml)
nyc311_loc <- nyc311_loc %>% 
  mutate(
    borough = ifelse(
      borough == "MANHATTAN", "MANHATTAN",
      ifelse(
        borough == "BRONX", "BRONX", 
        ifelse(
          borough == "BROOKLYN", "BROOKLYN_QUEENS", "BROOKLYN_QUEENS"
          )
        )
      )
    )
subloc_sml <- subloc_sml %>% 
  mutate(
    borough = ifelse(
      borough == "MANHATTAN", "MANHATTAN",
      ifelse(
        borough == "BRONX", "BRONX", 
        ifelse(
          borough == "BROOKLYN", "BROOKLYN_QUEENS", "BROOKLYN_QUEENS"
          )
        )
      )
    )
set.seed(2001)
test <- nyc311_loc %>% 
  sample_frac(0.001, replace = FALSE) %>% 
  full_join(subloc_sml, by = "borough") 
distances <- test %>% 
  mutate(
    dist.to.stat = distGeo(
      # p1 = NYC 311 location
      p1 = as.matrix(test %>% select(longitude, latitude)), 
      # p2 = subway station location
      p2 = as.matrix(test %>% select(avg_long, avg_lat))
      ) * 0.000621371  # convert meters to miles
    ) %>% 
  mutate(loc_id = paste(borough, latitude, longitude, sep = " / "))
min.distance <- distances %>% 
  group_by(loc_id) %>% 
  summarize(nearest.stat = min(dist.to.stat)) %>% 
  ungroup() %>% 
  inner_join((distances %>% select(longitude, latitude, loc_id)), by = "loc_id") %>% 
  unique()
nyc_loc_full_join <- nyc311_loc %>% 
  full_join(subloc_sml, by = "borough") 
p1 <- as.matrix(nyc_loc_full_join %>% select(longitude, latitude))
p2 <- as.matrix(nyc_loc_full_join %>% select(avg_long, avg_lat))
dist.to.stat <- distGeo(
      # p1 = NYC 311 location
      p1 = p1, 
      # p2 = subway station location
      p2 = p2
      ) * 0.000621371
nyc_loc_full_join$dist.to.stat <- dist.to.stat
nyc_loc_full_join$loc_id <- paste(nyc_loc_full_join$borough, nyc_loc_full_join$latitude, nyc_loc_full_join$longitude, sep = " / ")

nyc_loc_full_join %>% 
  summarize(
    mean.dist = mean(dist.to.stat),
    med.dist = median(dist.to.stat)
    )
nyc_loc_full_join %>% 
  ggplot(aes(dist.to.stat)) +
  geom_histogram(bins = 100) +
  geom_vline(xintercept = mean(dist.to.stat), color = "#E69F00", size = 2, alpha = 0.8) +
  geom_vline(xintercept = median(dist.to.stat), color = "#56B4E9", size = 2, alpha = 0.8) +
  ggtitle("Histogram of distances to all stations") +
  xlab("Distance from point in NYC to subway station\nWithin burrough") 
nyc_loc_full_join %>% 
  ggplot(aes(sqrt(dist.to.stat))) +
  geom_histogram(bins = 100) +
  geom_vline(xintercept = mean(sqrt(dist.to.stat)), color = "#E69F00", size = 2, alpha = 0.8) +
  geom_vline(xintercept = median(sqrt(dist.to.stat)), color = "#56B4E9", size = 2, alpha = 0.8) +
  ggtitle("Histogram of square root of distances to all stations") +
  xlab("Square Root of distance from point in NYC to subway station\nWithin burrough") 

nyc_loc_full_join %>%
  ggplot(aes(dist.to.stat)) +
  geom_histogram(bins = 100) +
  geom_vline(xintercept = mean(dist.to.stat), color = "#E69F00", size = 2, alpha = 0.8) +
  geom_vline(xintercept = median(dist.to.stat), color = "#56B4E9", size = 2, alpha = 0.8) +  
  ggtitle("Histogram of distances to ADA-Accessible stations only") +
  xlab("Distance from point in NYC to ADA-accessible subway station\nWithin burrough") +
  facet_wrap(~ada, nrow = 1)


all.distance <- nyc_loc_full_join %>% 
  select(-c(station_id, routes)) %>% 
  distinct() %>% 
  group_by(loc_id, borough, latitude, longitude) %>% 
  summarize(
    nearest.stat = min(dist.to.stat),
    mean.dist = mean(dist.to.stat),
    med.dist = median(dist.to.stat)
    ) %>% 
  ungroup() 
all.distance %>% 
  select(loc_id, nearest.stat:med.dist) %>% 
  gather(key = "Dist.type", value = "Distance", -loc_id) %>% 
  ggplot(aes(Distance)) +
  geom_histogram(bins = 50) +
  facet_wrap(~ Dist.type, nrow = 2)
all.distance %>% 
  select(loc_id, nearest.stat:med.dist) %>% 
  gather(key = "Dist.type", value = "Distance", -loc_id) %>% 
  ggplot(aes(Distance)) +
  geom_histogram(bins = 50) +
  facet_wrap(~ Dist.type, nrow = 1)
all.distance %>% 
  select(loc_id, borough, mean.dist:med.dist) %>% 
  gather(key = "Dist.type", value = "Distance", mean.dist:med.dist) %>% 
  ggplot(aes(Distance)) +
  geom_histogram(bins = 50) +
  facet_wrap(Dist.type ~ borough)

ada.distance <- nyc_loc_full_join %>% 
  filter(ada) %>% 
  select(-c(station_id, routes)) %>% 
  distinct() %>% 
  group_by(loc_id, borough, latitude, longitude) %>% 
  summarize(
    nearest.ada.stat = min(dist.to.stat),
    mean.ada.stat = mean(dist.to.stat),
    med.ada.stat = median(dist.to.stat)
    ) %>% 
  ungroup()
ada.distance %>% 
  select(loc_id, nearest.ada.stat:med.ada.stat) %>% 
  gather(key = "Dist.type", value = "Distance", -loc_id) %>% 
  ggplot(aes(Distance)) +
  geom_histogram(bins = 50) +
  facet_wrap(~ Dist.type, nrow = 2)
ada.distance %>% 
  select(loc_id, mean.ada.stat:med.ada.stat) %>% 
  gather(key = "Dist.type", value = "Distance", -loc_id) %>% 
  ggplot(aes(Distance)) +
  geom_histogram(bins = 50) +
  facet_wrap(~ Dist.type, nrow = 1)
ada.distance %>% 
  select(loc_id, borough, mean.ada.stat:med.ada.stat) %>% 
  gather(key = "Dist.type", value = "Distance", mean.ada.stat:med.ada.stat) %>% 
  ggplot(aes(Distance)) +
  geom_histogram(bins = 50) +
  facet_wrap(Dist.type ~ borough)
### top 5
all.top5.distance <- nyc_loc_full_join %>% 
  select(-c(station_id, routes)) %>% 
  distinct() %>% 
  group_by(loc_id, borough, latitude, longitude) %>% 
  top_n(-5, dist.to.stat) %>% 
  summarize(
    mean.top5.all = mean(dist.to.stat),
    med.top5.all = median(dist.to.stat)
  ) %>% 
  ungroup()
ada.top5.distance <- nyc_loc_full_join %>% 
  filter(ada) %>% 
  select(-c(station_id, routes)) %>% 
  distinct() %>% 
  group_by(loc_id, borough, latitude, longitude) %>% 
  top_n(-5, dist.to.stat) %>% 
  summarize(
    mean.top5.ada = mean(dist.to.stat),
    med.top5.ada = median(dist.to.stat)
  ) %>% 
  ungroup()
all.top5.distance %>% 
  select(loc_id, mean.top5.all:med.top5.all) %>% 
  gather(key = "Dist.type", value = "Distance", -loc_id) %>% 
  ggplot(aes(Distance)) +
  geom_histogram(bins = 100) +
  facet_wrap(~Dist.type)
ada.top5.distance %>% 
  select(loc_id, mean.top5.ada:med.top5.ada) %>% 
  gather(key = "Dist.type", value = "Distance", -loc_id) %>% 
  ggplot(aes(Distance)) +
  geom_histogram(bins = 100) +
  facet_wrap(~Dist.type)
```

####Plots of the results

Distance to any type of station from a particular point in NYC: 

```{r plot_any_dist_calc, fig.height=8, fig.width=8, comment=NA, eval=FALSE}
all.distance %>% 
  ggplot(aes(x = longitude, y = latitude, color = nearest.stat)) +
  geom_point(size = 0.2, alpha = 0.2) +
  scale_color_viridis(option = "B") +
  theme(panel.background = element_rect(fill = 'grey50')) +
  coord_quickmap() +
  ggtitle("Direct distance to any nearest subway station from point in NYC")
all.distance %>% 
  ggplot(aes(x = longitude, y = latitude, color = mean.dist)) +
  geom_point(size = 0.2, alpha = 0.2) +
  scale_color_viridis(option = "B") +
  theme(panel.background = element_rect(fill = 'grey50')) +
  coord_quickmap() +
  ggtitle("Direct distance to any nearest subway station from point in NYC")
ada.distance %>% 
  ggplot(aes(x = longitude, y = latitude, color = nearest.ada.stat)) +
  geom_point(size = 0.25, alpha = 0.2) +
  scale_color_viridis(option = "B") +
  theme(panel.background = element_rect(fill = 'grey50')) +
  coord_quickmap() +
  ggtitle("Direct distance to nearest ADA-Accessible subway station from point in NYC")
ada.distance %>% 
  ggplot(aes(x = longitude, y = latitude, color = mean.ada.stat)) +
  geom_point(size = 0.25, alpha = 0.2) +
  scale_color_viridis(option = "B") +
  theme(panel.background = element_rect(fill = 'grey50')) +
  coord_quickmap() +
  ggtitle("Direct distance to nearest ADA-Accessible subway station from point in NYC")
all.top5.distance %>% 
  ggplot(aes(x = longitude, y = latitude, color = mean.top5.all)) +
  geom_point(size = 0.2, alpha = 0.2) +
  scale_color_viridis(option = "B") +
  theme(panel.background = element_rect(fill = 'grey50')) +
  coord_quickmap()
ada.top5.distance %>% 
  ggplot(aes(x = longitude, y = latitude, color = mean.top5.ada)) +
  geom_point(size = 0.2, alpha = 0.2) +
  scale_color_viridis(option = "B") +
  theme(panel.background = element_rect(fill = 'grey50')) +
  coord_quickmap()


ggmap(nyc_map) +
  geom_point(data = all.distance, aes(x = longitude + 0.002, y = latitude - 0.002, color = mean.dist), size = 0.4, alpha = 0.5) +
  scale_color_viridis(option = "B")  +
  ylim(40.55, 40.915568) +  # NYC city limits latitude coordinates
  xlim(-74.1, -73.699215) +  # NYC city limits longitude coordinates
  xlab("longitude") +
  ylab("latitude") +
  ggtitle("Direct distance to any nearest subway station from point in NYC")
```


Unsurprisingly, some areas are just far from any subway stations and that carries over into what areas are far from ADA stations. 

```{r combining_distances, comment=NA, eval=FALSE}
dist.merge <- all.distance %>% 
  inner_join(
    ada.distance %>% select(-(borough:longitude)), 
    by = "loc_id"
    ) %>% 
  inner_join(
    all.top5.distance %>% select(-(borough:longitude)),
    by = "loc_id"
  ) %>% 
  inner_join(
    ada.top5.distance %>% select(-(borough:longitude)),
    by = "loc_id"
  )
glimpse(dist.merge)
# sanity checks for joining:
sapply(all.distance, anyNA)
sapply(ada.distance, anyNA)
sapply(dist.merge, anyNA)
# joining seems ok
dist.merge <- dist.merge %>% 
  mutate(
    # normalize dist to nearest station by subtraction
    any.vs.ada.min.dist = nearest.ada.stat - nearest.stat,
    # normalize dist to nearest station by division
    any.vs.ada.min.ratio = nearest.ada.stat / nearest.stat,
    # repeat for means
    any.vs.ada.mean.dist = mean.ada.stat - mean.dist,
    any.vs.ada.mean.ratio = mean.ada.stat / mean.dist,
    # repeat for med
    any.vs.ada.med.dist = med.ada.stat - med.dist,
    any.vs.ada.med.ratio = med.ada.stat / med.dist,
    # repeat for closest 5 stations means
    top5.any.vs.ada.mean.dist = mean.top5.ada - mean.top5.all,
    top5.any.vs.ada.mean.ratio = mean.top5.ada / mean.top5.all,
    # repeat for closes 5 station medians
    top5.any.vs.ada.med.dist = med.top5.ada - med.top5.all,
    top5.any.vs.ada.med.ratio = med.top5.ada / med.top5.all
    ) %>% 
  select(loc_id:longitude, starts_with("any.vs.ada"), starts_with("top5.any.vs.ada"))
glimpse(dist.merge)
```

Histogram of the distances:

```{r, fig.height=4, fig.width=8, comment=NA, eval=FALSE}
dist.merge %>% 
  select(loc_id:borough, ends_with(".dist")) %>% 
  rename(
    "Minimum_Diff" = any.vs.ada.min.dist,
    "Mean_Diff" = any.vs.ada.mean.dist,
    "Med_Diff" = any.vs.ada.med.dist,
    "Closest_5Stations_Mean_Diff" = top5.any.vs.ada.mean.dist,
    "Closest_5Stations_Med_Diff" = top5.any.vs.ada.med.dist) %>% 
  gather(key = "Dist.type", value = "Norm_Distance", -(loc_id:borough)) %>% 
  ggplot(aes(x = Norm_Distance)) +
  geom_histogram(bins = 100) +
  facet_wrap(~Dist.type) +
  xlab("Normalized Distance (miles)") +
  ggtitle("Difference in distance\nBetween nearest ADA-Accessible subway station and any subway station")
dist.merge %>% 
  ggplot(aes(any.vs.ada.min.dist)) +
  geom_histogram(bins = 100)
dist.merge %>% 
  ggplot(aes(any.vs.ada.med.dist)) +
  geom_histogram(bins = 100)
dist.merge %>% 
  ggplot(aes(top5.any.vs.ada.mean.dist)) +
  geom_histogram(bins = 100)
dist.merge %>% 
  ggplot(aes(top5.any.vs.ada.med.dist)) +
  geom_histogram(bins = 100)
dist.merge %>% 
  select(loc_id:borough, ends_with(".ratio")) %>%
  select(-any.vs.ada.min.ratio) %>% 
  rename(
    "Mean_Ratio" = any.vs.ada.mean.ratio,
    "Med_Ratio" = any.vs.ada.med.ratio,
    "Closest_5Stations_Mean_Ratio" = top5.any.vs.ada.mean.ratio,
    "Closest_5Stations_Med_Ratio" = top5.any.vs.ada.med.ratio
  ) %>% 
  gather(key = "Dist.type", value = "Norm_Distance", -(loc_id:borough)) %>% 
  ggplot(aes(x = Norm_Distance)) +
  geom_histogram(bins = 100) +
  facet_wrap(~Dist.type) +
  xlab("Ratio") +
  ggtitle("Ratio in distance\nBetween nearest ADA-Accessible subway station and any subway station")
dist.merge %>% 
  ggplot(aes(any.vs.ada.mean.ratio)) +
  geom_histogram(bins = 100)
dist.merge %>% 
  ggplot(aes(any.vs.ada.med.ratio)) +
  geom_histogram(bins = 100)
dist.merge %>% 
  ggplot(aes(top5.any.vs.ada.mean.ratio)) +
  geom_histogram(bins = 100)
dist.merge %>% 
  ggplot(aes(top5.any.vs.ada.med.ratio)) +
  geom_histogram(bins = 100)
```  

Maps of the normalized distances to ADA-Accessible stations:
  
```{r norm_subtract_viz, fig.width=8, fig.height=8, comment=NA, eval=FALSE}
### subtraction normalization
dist.merge %>% 
  ggplot(aes(x = longitude, y = latitude, color = any.vs.ada.min.dist)) +
  geom_point(size = 0.1) +
  scale_color_viridis(option = "B") +
  theme(panel.background = element_rect(fill = 'grey50')) +
  coord_quickmap() +
  ggtitle("Direct distance to nearest ADA-accessible subway station from point in NYC\nNormalized to distance to nearest any kind of subway station (subtraction)") +
  xlab("Longitude") +
  ylab("Latitude")
dist.merge %>% 
  ggplot(aes(x = longitude, y = latitude, color = any.vs.ada.min.dist)) +
  geom_point(size = 0.2, alpha = 0.3) +
  scale_color_viridis(option = "B") +
  theme(panel.background = element_rect(fill = 'grey50')) +
  coord_quickmap() +
  ggtitle("Direct distance to nearest ADA-accessible subway station from point in NYC\nNormalized to distance to nearest any kind of subway station (subtraction)") +
  xlab("Longitude") +
  ylab("Latitude")
dist.merge %>% 
  ggplot(aes(x = longitude, y = latitude, color = any.vs.ada.med.ratio)) +
  geom_point(size = 0.2, alpha = 0.3) +
  scale_color_viridis(option = "B") +
  theme(panel.background = element_rect(fill = 'grey50')) +
  coord_quickmap()
dist.merge %>% 
  ggplot(aes(x = longitude, y = latitude, color = top5.any.vs.ada.mean.dist)) +
  geom_point(size = 0.2, alpha = 0.3) +
  scale_color_viridis(option = "B") +
  theme(panel.background = element_rect(fill = 'grey50')) +
  coord_quickmap()
dist.merge %>% 
  ggplot(aes(x = longitude, y = latitude, color = top5.any.vs.ada.mean.ratio)) +
  geom_point(size = 0.2, alpha = 0.3) +
  scale_color_viridis(option = "B") +
  theme(panel.background = element_rect(fill = 'grey50')) +
  coord_quickmap()
```


What are the rough locations under-serviced? Google map can help here, even though it's not perfect.

```{r dist_sub_map, fig.width=8, fig.height=8, comment=NA, eval=FALSE}
ggmap(nyc_map) +
  geom_point(data = dist.merge, aes(x = longitude + 0.002, y = latitude - 0.002, color = any.vs.ada.min.dist), size = 0.2) +
  scale_color_viridis(option = "B")  +
  ylim(40.55, 40.915568) +  # NYC city limits latitude coordinates
  xlim(-74.1, -73.699215) +  # NYC city limits longitude coordinates
  xlab("Longitude") +
  ylab("Latitude") +
  ggtitle("Direct distance to nearest ADA-accessible subway station from point in NYC\nNormalized to distance to nearest any kind of subway station (subtraction)")
```


The ratio normalization doesn't really work so well, the subtraction is probably the better choice in this case.

Next steps:
- Separate distance calculations by borough for both the random point and the station, in case "closest" stations are across a river. Probably can keep Queens and Brooklyn together?
- Incorporate outage data to find the "true" dead zones? Or areas that are usually suffering from long-term outages of accessibility equipment?
- Find a better NYC map overlay - is it the 311 long,lat data that's the problem, or the map I got from ggmap? 


```{r, eval = FALSE}
test.map <- readOGR("./data/nyct2010_18a", "nyct2010")
tm_shape(test.map) +
  tm_borders() 
test.map2 <- fortify(test.map)
ggplot(test.map2, aes(x = long, y = lat, group = group)) +
  geom_polygon(fill = NA, color = "black")
test.map3 <- test.map[test.map$BoroName != "Staten Island", ]
tm_shape(test.map3) +
  tm_borders() 
dist.points <- SpatialPoints(dist.merge[, c(4, 3)])
proj4string(dist.points) <- CRS("+init=epsg:4326")
#proj4string(dist.points) <- CRS("+proj=lcc +lat_1=41.03333333333333 +lat_2=40.66666666666666 +lat_0=40.16666666666666 +lon_0=-74 +x_0=300000.0000000001 +y_0=0 +ellps=GRS80 +datum=NAD83 +to_meter=0.3048006096012192 +no_defs")
plot(dist.points)
dist.points <- spTransform(dist.points, proj4string(test.map3))
dist.by.tract <- over(dist.points, test.map3)
dist.by.tract.frt <- fortify(dist.by.tract)
test4 <- dist.merge %>% 
  bind_cols(dist.by.tract.frt)
test5 <- test4 %>% 
  group_by(CT2010) %>% 
  summarize(avg_to_ada_stat = mean(top5.any.vs.ada.mean.dist))
test6 <- test4 %>% 
  group_by(NTAName) %>% 
  summarize(avg_to_ada_stat = mean(top5.any.vs.ada.mean.dist)) %>% 
  arrange(desc(avg_to_ada_stat))
merge.to.map <- merge(test.map3, test5, by.x = "CT2010", by.y = "CT2010")
merge.to.map2 <- merge.to.map
merge.to.map2[str_detect(merge.to.map2$NTAName, "park-cemetery-etc") | str_detect(merge.to.map2$NTAName, "Airport"), ] <- NA
tm_shape(merge.to.map2) +
  tm_fill("avg_to_ada_stat", style = "fixed", breaks = c(0, 0.25, 0.5, 0.75, 1, 1.25, 1.5, 3, 5.9643), palette = viridis(n = 8, option = "A"))
tm_shape(merge.to.map2) +
  tm_fill("avg_to_ada_stat", style = "fixed", breaks = c(0, 0.25, 0.5, 0.75, 1, 1.25, 1.5, 3, 5.9643), palette = viridis(n = 8, option = "B"))
tm_shape(merge.to.map2) +
  tm_fill("avg_to_ada_stat", style = "fixed", breaks = c(0, 0.25, 0.5, 0.75, 1, 1.25, 1.5, 3, 5.9643), palette = viridis(n = 8, option = "C"))
tm_shape(merge.to.map2) +
  tm_fill("avg_to_ada_stat", style = "fixed", breaks = c(0, 0.25, 0.5, 0.75, 1, 1.25, 1.5, 3, 5.9643), palette = viridis(n = 8, option = "D"))
tm_shape(merge.to.map2) +
  tm_fill("avg_to_ada_stat", style = "fixed", breaks = c(0, 0.25, 0.5, 0.75, 1, 1.25, 1.5, 3, 5.9643), palette = viridis(n = 8, option = "E"))
tm_shape(merge.to.map2) +
  tm_borders() +
  tm_fill("avg_to_ada_stat", style = "fixed", breaks = c(0, 0.25, 0.5, 0.75, 1, 1.25, 1.5, 3, 5.9643), palette = viridis(n = 8, option = "A"))
merge.to.map.neigh <- merge(test.map3, test6, by.x = "NTAName", by.y = "NTAName")
merge.to.map.neigh[str_detect(merge.to.map.neigh$NTAName, "park-cemetery-etc") | str_detect(merge.to.map.neigh$NTAName, "Airport"), ] <- NA
tm_shape(merge.to.map.neigh) +
  tm_borders()+
  tm_fill("avg_to_ada_stat", midpoint = NA, palette = viridis(n = 6, option = "A"))

sum(str_detect(merge.to.map$NTAName, "park-cemetery-etc"))
merge.parks <- merge.to.map[str_detect(merge.to.map$NTAName, "park-cemetery-etc"),]
tm_shape(merge.parks) +
  tm_fill()
```