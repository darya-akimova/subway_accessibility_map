---
title: "The Inaccessible Subway: A Geospatial Analysis of the NYC Subway in R"
author: "Darya Akimova"
output: 
  html_document:
    toc: true
    toc_float:
      smooth_scroll: false
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)
```


# Introduction {.tabset .tabset-fade .tabset-pills}

## Background

TO EDIT

This project was initially sparked by the Data for Democracy NYC Accessibility project ( [ Project GitHub Repo](https://github.com/Data4Democracy/nyc-accessibility) ).

* ADA-Accessibility defintion - 
* NYC subway has a funding problem
* Link news articles 
* Plan set to update the system, but NYC has a history of bypassing upgrades to improve/increase assessibility

Assessibility concerns usually bring to mind someone in a wheelchair, but an accessible system can help many:
  + parents with young children and strollers
  + people with temporary/not obvious injuries 
  + senior citizens 
  + someone who may have spent all day working on their feet


## Project Problems and Goals

TO EDIT

Main goal: Imitate and improve upon the spatial analysis conducted in the: [July 2018 NYC Comptroller Report ](https://comptroller.nyc.gov/reports/service-denied-accessibility-and-the-new-york-city-subway-system/)

Problems with report to address:

Problem 1: NYC neighborhoods are areas that people can easily identify with, but they are very large in terms of area
Proposed solution: Use the 2010 Census tracts instead, which are smaller in terms of area

Problem 2: The report counts stations that are only within the boundaries of a neighboorhood, this is limiting and may be inaccurate if the station is located on the edge of a large neighborhood
Proposed solution: Consider stations only within a certain radius of a geographical point, such as the center of the census tracts

Problem 3: Report focuses on the presence/absence of a subway station or ADA-accessible subway station, but no info on how many stations are in the neighborhood
Proposed solution: Count unique route station stops, including the total number and ADA-accessible stations, within a given geographical area 


## Data Science Skills Utilized

TO EDIT

I had been curious about geospatial analysis for a while, and this project was a great excuse to learn more. However, this project also turned out to require quite a lot of data cleaning, especially of the Subway Entrances and Exits dataset.

The skills utilized and demonstrated throughout this work are:

* Data cleaning - I had severely underestimated how messy and out-of-date the NYC Subway Entrances and Exits dataset was. It needed quite a lot of manual curation in the end to reach a ready state.
* Geospatial analysis in R - mapping, spatial joins, converting non-spatial data into spatial format, andmore, mainly with the help of the `sf` package (LINK). As an aside, this [DataCamp course on the sf package, led by Zev Ross](https://www.datacamp.com/courses/spatial-analysis-in-r-with-sf-and-raster), was immensely helpful.


# Setup {.tabset .tabset-fade .tabset-pills}

## Packages

Packages used:

* tidyverse - omnibus package for data import, wrangling, and cleaning 
* sf - geospatial analysis
* ggthemes - ggplot2 theme and palette add-on 

```{r packages, comment=NA}
library(tidyverse)
library(sf)
library(ggthemes)
# minimal theme for nice plots throughout the project
theme_set(theme_minimal())
```


## Data

Shapefiles, imported using the `st_read` function from the `sf` package
* `nyc.census.map`: Shapefile of NYC 2010 census tract boundaries
* `nyc.neigh.map`: Shapefile of NYC neighborhoods

Datasets, in .csv format:
* `subway.ent.exit`: Subway Entrances and Exits dataset, which provides information about which subway routes stop at each station, whether the stations are ADA-accessible or not, as well as the station latitude and longitude coordinates, but in a non-spatial format with no coordinate reference system.  
* `subway.by.line`: In NYC, the subway routes are grouped into "trunk lines", which indicates that in at least some sections of the route they share many of the same stops. Some may be local or express in different areas of the city, and they may split somewhere, but in at least some sections they overlap significantly. Each line grouping also has its own distinct color. This dataset provides information on line grouping by trunk line and color codes.
* `num.stat.by.rt.wiki`: Numer of station stops by route according to wikipedia. This will be used later to clean the subway entrances/exits dataset. As an aside, NYC subway service changes over the course of the day and the weekend, with some lines switching from express to local or going out of serivce all together, for example. In this analysis, I will be be focusing on the weekday rush-hour service because, in theory, that is when the most people should be using the subway and it is most needed. 


```{r data_import, comment=NA}
### shapefiles ###
nyc.census.map <- st_read("./data/nyct2010_18a/nyct2010.shp")
nyc.neigh.map <- st_read("./data/nynta_18d/nynta.shp")
### subway info ###
subway.ent.exit <- read_csv("./data/2018_update/NYC_Transit_Subway_Entrance_And_Exit_Data.csv")
subway.by.line <- read_csv("./data/2018_update/nyc_subway_stations_grouped.csv")
num.stat.by.rt.wiki <- read_csv("./data/2018_update/nyc_subway_num_stat_by_line.csv")
```

Data sources: 

* NYC Census Map shapefile: [NYC Department of City Planning Open Data Website](https://www1.nyc.gov/site/planning/data-maps/open-data/districts-download-metadata.page)
* NYC Neighborhood Tabulation Areas Map shapefile: [NYC Department of City Planning Open Data Website](https://www1.nyc.gov/site/planning/data-maps/open-data/dwn-nynta.page)
* Subway Entrances and Exits: [Open Data NY](https://data.ny.gov/Transportation/NYC-Transit-Subway-Entrance-And-Exit-Data/i9wp-a4ja)
* Subway by Line Info: Copied from the [NYC Subway Wikipedia Page](https://en.wikipedia.org/wiki/New_York_City_Subway)
* Number of Subway Stations by Route: Collected from each individual subway route page, such as this page for [the E subway service](https://en.wikipedia.org/wiki/New_York_City_Subway)


## Data Preview

The NYC census tract and neighborhood `sf` files can be visualized in a number of ways, including ggplot2 and the `plot` function. Here, ggplot is used to layer the census tracts in blue and the neighborhood boundaries in orange to demonstrate the difference, for those not familiar with the city. 

```{r nyc_maps_plot, comment=NA}
# nyc census tracts map in blue
nyc.census.map %>% 
  ggplot() +
  geom_sf(color = "#1F77B4") +
  # nyc neighborhoods outlines overlaid in orange
  geom_sf(data = nyc.neigh.map, color = "#FF7F0E", size = 1, fill = NA) +
  ggtitle("NYC Map") +
  xlab("Longitude") +
  ylab("Latitude")
```


With the exception of parks and airports, most neightborhood tracts include multiple census tracts. Both shapefiles also include Staten Island, for which there is no data in the subway entrances/exits dataset and therefore it will be removed. The rail system there is not considered a part of the subway system per se. 

A very useful feature of the `sf` format, is that these objects are data.frames and can be treated as such for the purposes of filtering, joining, and other manipulations, as well as spatial objects. 

```{r census_map_summary, comment=NA}
summary(nyc.census.map)
```

For example, as demonstrated above, the `nyc.census.map` object includes the tract codes, the city borough name that that tract belongs to, as well as the geometry.

As for the other datasets, the Subway Entrances and Exits dataset contains the most useful and relevant information for this project, but will require considerable transformation to get it into a usable format.

```{r raw_dataset_glimpse, comment=NA}
# subway entrances/exit data:
glimpse(subway.ent.exit)
# subway summary data
glimpse(subway.by.line)
# num of station stops by route:
glimpse(num.stat.by.rt.wiki)
```


Preliminary to-do list:

* Remove Staten Island from the maps - the subway datasets do not include the Staten Island route
* `subway.ent.exit`: the entrances and exits dataset is very messy, needs cleaning and reogranization into a tidy format. However, it already contains geospatial coordinates for each station, which subway routes stop at that station, and ADA-Accessibility information
* `subway.by.line`: needs to be tidied, with each subway route as its own row
* `num.stat.by.rt.wiki`: is fine as is


# Preliminary exploration and cleaning {.tabset .tabset-fade .tabset-pills}

## Basic cleaning

For the maps, Staten Island will be filtered out, the borough name will be converted to lowercase and the column names will be converted to lowercase for later convenience.

```{r nyc_map_edit, comment=NA}
nyc.census.4boro <- nyc.census.map %>%  
  filter(BoroName != "Staten Island") %>% 
  mutate(BoroName = str_to_lower(BoroName)) %>% 
  `colnames<-`(str_to_lower(colnames(nyc.census.map)))
nyc.neigh.4boro <- nyc.neigh.map %>% 
  filter(BoroName != "Staten Island") %>% 
  mutate(BoroName = str_to_lower(BoroName))%>% 
  `colnames<-`(str_to_lower(colnames(nyc.neigh.map)))
# new column names:
colnames(nyc.census.4boro)
colnames(nyc.neigh.4boro)
ggplot(nyc.neigh.4boro) +
  geom_sf() +
  ggtitle("NYC Neighborhoods Map\nNo Staten Island") +
  xlab("Longitude") +
  ylab("Latitude")
```


For the other dataframes, first cleanup the column names of the two subway info dataframes by converting the words to lower-case and by replacing empty spaces to make them easier to work with:

```{r comment=NA}
colnames(subway.ent.exit) <- colnames(subway.ent.exit) %>% 
  str_to_lower() %>% 
  str_replace_all(" ", "_")
colnames(subway.ent.exit)
colnames(subway.by.line) <- colnames(subway.by.line) %>% 
  str_to_lower() %>% 
  str_replace_all(" ", "_")
colnames(subway.by.line)
```


Much better! 

Next, the `lines` column in the `subway.by.line` dataset needs to be separated so that each subway line is its own row. 

```{r sub_line_tidy, comment=NA}
sub.line.tidy <- subway.by.line %>% 
  # separate the route names into their own columns (wide format)
  separate(lines, into = c(paste("route", 1:4, sep = "_")), remove = FALSE) %>% 
  # gather the separated route names into one column (long format)
  gather("route_num", "route_name", route_1:route_4) %>% 
  # remove extra rows created from extra columns where there fewer than 4 routes for that line
  filter(!is.na(route_name)) %>% 
  # unnecessary column: 
  select(-route_num) %>% 
  arrange(route_name)
head(sub.line.tidy)
```


Now that that dataset is clean, it is possible to check the route names against the entrances/exits data in order to determine if there is anything odd or any typos:

```{r comment=NA}
subway.ent.exit %>% 
  # gather the unique route names across all of the route columns in the subway ent/exit dataset:
  select(route1:route11) %>% 
  gather("route_num", "route_name") %>% 
  filter(!(is.na(route_name))) %>% 
  select(-route_num) %>% 
  distinct() %>% 
  # any route names in the ent/exit df that are not in the official route list on the wiki?
  anti_join(sub.line.tidy, by = "route_name")
```

Yes, it looks like there are four routes in the subway entrance/exit data that are not in the route list. However, the `e` is simply a typo that should be changed to `E`, which is a real route, and the three routes `GS`, `FS`, and `H` all fall under the umbrella of `S` in the wiki route list. They are their own separate, relatively short routes, that all fall under the designation of shuttles. `GS` is the 42nd St shuttle in Manhattan that only stops in Times Square and Grand Central. `FS` is the Franklin Avenue shuttle that operates between Franklin Ave and Prospect Park in Brooklin. Lastly, `H` is the Rockaways shuttle.

On to the subway entrances/exits dataset itself. First and foremost, according to wikipedia, there should be what is considered by the city 472 subway stations or 424 if the connected stations are considered single stations. I expect that the raw dataset will be off in some regard, since it was not even updated with the Second Avenue subway stations and the changes to Q route service, which also added 3 stations in Manhattan. 

```{r stat_name_num_check, comment=NA}
# number of unique subway station names:
length(unique(subway.ent.exit$station_name))
```


That is far too few stations, but that is not a surprise given that station names are often reused, for example there are 5 "23rd Street" stations in Manhattan and 1 in Queens. Therefore, the station name column alone cannot be used as a unique key for the stations in this dataset. 

What about other alternatives? The subway by line dataset had special codes and names to refer to the trunk line, such as IRT and BMT, which matches the `division` and `line` columns in the entrances/exits data. I suspect that the division, line, and station_name columns will give the unique identifier for each station. But how many unique combinations of those 3 columns are there?

```{r stat_name_div_check, comment=NA}
subway.ent.exit %>% 
  select(division:station_name) %>% 
  distinct() %>% 
  head()
subway.ent.exit %>% 
  select(division:station_name) %>% 
  distinct() %>% 
  nrow()
```

There are 465 such combinations, which is close to the 472 number. Adding in 3 missing new Q-train stations brings it up to 468, but there may be more stations missing than I thought.

As an aside, how many station name, latitude, and longitude combinations are there? 

```{r stat_name_lat_long_count, comment=NA}
subway.ent.exit %>% 
  select(station_name, station_latitude:station_longitude) %>% 
  distinct() %>% 
  nrow()
```

There are more of those combinations than there are stations. It turns out that some stations had multiple coordinates, which is likely related to the entrances and exits, or maybe due to connected stations.

Now for some cleanup of the subway entrance/exit dataset:

* Create a (theoretically) unique station name column by combining the division. line, and station_name
* Fix the capitalization typo

```{r sub_ext_key_create, comment=NA}
sub.ent.w.key <- subway.ent.exit %>% 
  mutate_at(vars(division:station_name), str_to_lower) %>% 
  # create a unique key for each station
  unite("stat_name", division:station_name, sep = "_") %>% 
  # capitalize all of the route names (to fix the e issue)
  mutate_at(vars(route1:route11), str_to_upper) 
sub.ent.w.key <- sub.ent.w.key %>% 
  select(-c(station_latitude:station_longitude)) %>% 
  distinct() %>% 
  left_join(
    sub.ent.w.key %>% 
      select(stat_name:station_longitude) %>% 
      distinct() %>% 
      group_by(stat_name) %>% 
      summarize(
        avg_stat_lat = mean(station_latitude),
        avg_stat_long = mean(station_longitude)
        ),
    by = "stat_name"
    )
length(unique(sub.ent.w.key$stat_name))
sub.ent.w.key %>% 
  select(stat_name, avg_stat_lat:avg_stat_long) %>% 
  distinct() %>% 
  nrow()
```

Now the number of unique station names and the combination of station names and geographical locations are equal.


## Entrance Analysis

Apart from the subway station location information, the entrances and exits dataset provides information on, well, the entrances and exits. What additional information does this provide? Is it useful in any way and does it give some extra insights? How many of each entrance type are there and what is the relationship between the entrance types and the ADA-accessibility rating of the station?

```{r sub_entrance_step1, comment=NA}
# take unique station name and entrance information, as well as the ada rating
sub.entrances <- sub.ent.w.key %>% 
  select(stat_name, entrance_latitude:entrance_longitude, entrance_type:entry, ada) %>%
  distinct()
# result:
head(sub.entrances)
table(sub.entrances$entrance_type)
table(sub.entrances$ada)
```


Stairs are by far the most common entrance/exit type, which is something new learned, but the ADA count by itself doesn't add much. I'm curious what the relationship between the ADA rating and the entrance type is per station:

```{r sub_entrace_per, comment=NA}
sub.entrances %>% 
  group_by(stat_name) %>% 
  summarize(
    # count total number of entrances:
    num_entry = n(),
    # ada is TRUE/FALSE - can sum to get number of ada = TRUE per station:
    num_ada = sum(ada),
    # % ada out of total num of entrances, per station:
    percent_ada = num_ada * 100 / num_entry
  ) %>% 
  {table(.$percent_ada)}
```


The result is either the stations are either 0% ADA or 100% ADA, which indicates that the ADA TRUE/FALSE rating is given to the entire station, not the particular entrance/exit. This suddenly makes the entrance columns a lot less interesting to me, and I will remove them from consideration after a few more plots.

!: WHat are the most comment entrance types for ADA-accessible and not accessible stations?

```{r sub_entrance_count_plot, comment=NA}
sub.entrances %>% 
  group_by(entrance_type, ada) %>% 
  count() %>% 
  ggplot(aes(entrance_type, n, fill = ada)) +
  geom_bar(stat = "identity", position = "dodge") +
  theme_minimal() +
  xlab("Entrance Type") +
  ylab("Count") +
  scale_fill_tableau()
```

Stairs by far are the most common, and in general stations that have stair entrances are more often ADA = FALSE than not, but the size of the Stairs bars dominates the plot, so what about a different view?


```{r sub_entrances_fill_plot, comment=NA}
sub.entrances %>% 
  group_by(entrance_type, ada) %>% 
  count() %>% 
  ggplot(aes(entrance_type, n, fill = ada)) +
  geom_bar(stat = "identity", position = "fill") +
  theme_minimal() +
  xlab("Entrance Type") +
  ylab("Proportion") +
  scale_fill_tableau()
```

This alternative view shows that Elevator entrances tend to denote ADA-accessible stations, more often than not. I tried to search, but I'm not sure what an "easement" entrance may be, it sounds like a private entrance, perhaps for utility work. A typical accessible routes are elevators and escalators, although I believe an elevator is required for a station to be fully ADA-accessible. (source?)


## Removing entrance info and tidying more

Now to remove the entrance information, since it does not seem that useful for my purpose, and to convert the route columns into a tidy format. In order to replicate the geospatial analysis done in the official report, the route information is not necessary and could be dropped at this point. However, my interest lies in how many stations are located within certain spatial areas. I intend to treat each train route stop individually and to count each train that stops at a station individual. So if 3 trains, say the 4, 5, and 6 trains, all stop at one station, I would like to be able to count each of those because the more trains stop in a given area, the more "accessible" or reachable by subway that area is.

```{r sub_ent_tidy, comment=NA}
sub.ent.sml <- sub.ent.w.key %>% 
  # select relevant columns, discard all others from this point on
  select(stat_name, avg_stat_lat:avg_stat_long, route1:route11, ada, ada_notes) %>% 
  distinct() %>% 
  # reformat the route columns into a long format
  gather("route_num", "route_name", route1:route11) %>% 
  # get rid of the many NAs in the route column that were there due to the formatting
  filter(!is.na(route_name)) %>% 
  select(-route_num) %>% 
  distinct()
# new format
dim(sub.ent.sml)
head(sub.ent.sml)
# number of unique stations and train route combinations:
sub.ent.sml %>% 
  select(stat_name, route_name) %>% 
  distinct() %>% 
  nrow()
# missing values check:
sapply(sub.ent.sml, anyNA)
```


At least formatting wise, the subway station and route dataset is much neater, with each route now on its own row instead of in columns, along with the ADA rating and station location. I've also taken along the `ada_notes` column which is not NA for a small number of stations and should be easier to explore now that the dataset of interest is much smaller. 


## Trouble ahead

```{r ada_notes_show, comment=NA}
sub.ent.sml %>% 
  select(stat_name, ada, ada_notes) %>% 
  distinct() %>% 
  filter(!(is.na(ada_notes)))
```

These notes were the first real sign of trouble ahead. 

Here are some of the next action plans based on these notes: 
* Some ADA changes were under construction or in planning at the time - need to check if construction at these stations has been completed and the ADA = FALSE can be changed to TRUE
* Some of the stations are ADA-accessible in only one direction (northbound or southbound only). In the case of this analysis, I decided to allow ADA = TRUE for the entire station if it was ADA-accessible in at least one direction, since for my purposes it did not make sense to count a station as "half-accessible". 
* Some stations, even though from the previous steps it was determined that the stations were either all ADA-accessible or not, are not fully accessible to all the trains that stop at that station. For example, the Union Square station is rated as ADA-accessible for the L, N, Q, R, and W trains, but not for the Lexington Ave 4, 5, and 6 trains. This is a consequence of the original formatting of the data. Because for me it is important to get the count right for each individual train, I would need to correct this and change ADA = FALSE where appropriate.
* Some stations seem to be listed twice because different trunk lines stop there. For example, again, Union Square, which is considered one station, but is listed as `bmt_broadway_union square` for the N/Q/R/Q trunk line and `bmt_canarsie_union square` for the L trunk line. 

This was my first real sign of just how messy this dataset is in its current state. Most worrying for my purposes was that it turned out that for each connected station, all the train route names are repeated. For example, there is a World Trade Center stop where only the E stops. But some subway stations are connected underground by tunnels and one can transfer from one station to another. 

If I filter for this station only, where only the E should stop, I instead get 5 trains at this station as a result:

```{r ind_world_trade_lookup, comment=NA}
sub.ent.sml %>% 
  filter(stat_name == "ind_8 avenue_world trade center")
```

This is because the World Trace Center stop is connected to the Park Place stop, where the 2 and 3 stop, and Chambers St, where the A and C stop. 

Now, if I select for the Park Place station information:

```{r irt_park_place, comment=NA}
sub.ent.sml %>% 
  filter(stat_name == "irt_clark_park place")
```

Thankfully, the ADA rating is separate from the World Trade Center stop and is correctly marked as FALSE, but the issue is that all of the trains are also listed as stopping at this station, even though only the 2 and 3 trains should stop here, on top of the 1 train being listed here for some reason, even though the 1 route does not follow the 2 and 3 in this part of Manhattan. 

More worrying, is that based on the data I got from wikipedia, the associated "line" names with the IND division, for example, should only be:

```{r ind_line_names, comment=NA}
sub.line.tidy %>% 
  filter(str_detect(primary_trunk_line, "IND")) %>% 
  select(primary_trunk_line) %>% 
  distinct()
```


However, the line names for the subway entrances/exit data are far more varied:

```{r ind_sub_ent_line_names, comment=NA}
sub.ent.sml %>%
  select(stat_name) %>% 
  distinct() %>% 
  # select only the IND division subway station stops
  filter(str_detect(stat_name, "ind")) %>% 
  # separate out the different name parts again
  separate(stat_name, into = c("division", "line", "station_name"), sep = "_") %>% 
  {table(.$line)}
```


Yes, the 8th Ave, 6th Ave, and Crosstown lines are there (although in a different format), but so are a number of other line names. This suggests that I cannot reliably use the line information, and maybe even the division codes to filter the subway station and train route combinations. 

It also seems that the dataset was far more out of date than I expected. For example, the G Train Route is missing station stops between Smith 9th St and Church Ave, where the service was extended to some time ago. Luckily, in this case at least, those stations could just be added in by adding in a part of the F train route.

```{r g_train_add, comment=NA}
# transform the neighborhood map crs to march the subway entrance/exit data:
nyc.map.4boro.stat.crs <- st_transform(nyc.neigh.4boro, crs = "+init=epsg:4326")
nyc.map.4boro.stat.crs %>% 
  ggplot() +
  geom_sf(fill = NA) +
  geom_point(
    data = sub.ent.sml %>% 
      filter(route_name == "G"),
    aes(avg_stat_long, avg_stat_lat, color = route_name),
    size = 2, alpha = 0.8
    ) +
  xlab("Longitude") +
  ylab("Latitude") +
  theme(legend.position = "none") +
  ggtitle("G Train Route (Outdated)")
# should add those in - follows the F train here, get the slice of stations: 
sub.ent.sml %>% 
  filter(route_name == "F") %>% 
  arrange(avg_stat_lat) %>% 
  filter(avg_stat_lat > 40.62976 & avg_stat_lat < 40.68030)
# G train is considered IND - grab that 4th ave station
sub.ent.sml <- sub.ent.sml %>% 
  bind_rows(
    sub.ent.sml %>% 
      filter(route_name == "F") %>% 
      arrange(avg_stat_lat) %>% 
      filter(avg_stat_lat > 40.63612 & avg_stat_lat < 40.67358 & str_detect(stat_name, "ind")) %>% 
      mutate(route_name = "G")
)
# Updated G train route:
nyc.map.4boro.stat.crs %>% 
  ggplot() +
  geom_sf(fill = NA) +
  geom_point(
    data = sub.ent.sml %>% 
      filter(route_name == "F" | route_name == "G"),
    aes(avg_stat_long, avg_stat_lat, color = route_name),
    size = 2, alpha = 0.8
    )+
  xlab("Longitude") +
  ylab("Latitude") +
  scale_color_discrete(name = "Route") +
  ggtitle("G and F Train Routes (Updated)")
```


The updated route length is correct, but now there are too many stations than expected:

```{r}
# new number of G train stations:
sub.ent.sml %>%
  filter(route_name == "G") %>% 
  nrow()
num.stat.by.rt.wiki %>% 
  filter(route_name == "G")
```

At this point, I'm starting to think that I'll need to manually check through the station and train associations, but first I will go back to the ada_notes issue and fix that before moving on.


## ADA fixes and hitting a wall


To fix:

* ind_8 avenue_50th st / TRUE / Southbound Only - Leave as ada = TRUE (no changes)
* ind_8 avenue_world trade center / TRUE / Construction - ada = TRUE for E only 
* ind_archer av_sutphin blvd-archer av - jfk / TRUE / Check - ada = TRUE according to wikipedia page (no change)
* bmt_broadway_49th st / TRUE / Northbound Only - Leave as ada = TRUE (no change)
* bmt_broadway_times square-42nd st / TRUE / Shuttle not ADA - set S to ada = FALSE
* bmt_broadway_union square / TRUE / Lex not ADA - set 4/5/6 to ada = FALSE   
* bmt_canarsie_union square / TRUE / Lex not ADA - same as above      
* ind_concourse_kingsbridge rd / FALSE / in planning - switch to TRUE because it is complete      
* irt_lexington_23rd st / FALSE In Planning - switch to TRUE because it is complete
* irt_lexington_brooklyn bridge-city hall / TRUE / J Z not ADA - set J/Z to ada = FALSE
* irt_lexington_canal st / TRUE / Bway Nass not ADA - Only set 6 ada  = TRUE
* irt_pelham_hunts point av / FALSE / in planning - complete, set ada = TRUE     
* ind_queens boulevard_forest hills-71st av / FALSE / in planning - complete, set ada = TRUE


An additional small fixt that I noticeds is that there are two redundant routes: GS and S routes that refer to the same thing, the grand central shuttle between times square and grand central. Therefore I will filter out the "S" route and change the GS ADA column to FALSE, since it is not ADA-accessible at neither Times Square nor Grand Central.

I chose to keep each change as a separate mutate call simply to keep track of the changes, although it is inefficient.

```{r ada_notes_fix, comment=NA}
sub.ent.ada.updt <- sub.ent.sml %>% 
  # change world trade center station ada
  mutate(ada = ifelse((stat_name == "ind_8 avenue_world trade center" & route_name != "E"), FALSE, ada)) %>% 
  # change times square shuttle ada, filter out extra "S" route
  filter(route_name != "S") %>% 
  mutate(ada = ifelse(route_name == "GS", FALSE, ada)) %>% 
  # change 4/5/6 at union square to ada = FALSE
  mutate(ada = ifelse(
      ((stat_name == "bmt_broadway_union square" | stat_name == "bmt_canarsie_union square") &
         (route_name == "4" | route_name == "5" | route_name == "6")), 
      FALSE, ada
      )) %>% 
  # change kingsbridge rd ada = TRUE
  mutate(ada = ifelse(stat_name == "ind_concourse_kingsbridge rd", TRUE, ada)) %>% 
  # change Lex / 23rd St stop to TRUE
  mutate(ada = ifelse(stat_name == "irt_lexington_23rd st", TRUE, ada)) %>% 
  # change J/Z at Brooklyn Bridge / City Hall to ada = FALSE
  mutate(ada = ifelse(
    (stat_name == "irt_lexington_brooklyn bridge-city hall" & (route_name == "J" | route_name == "Z")),
    FALSE, ada
    )) %>% 
  # change irt_lexington_canal st to ada = TRUE for 6 train only
  mutate(ada = ifelse(
    (stat_name == "irt_lexington_canal st" & route_name != "6"), FALSE, ada
    )) %>% 
  # change rt 6 hunts point av to ada = TRUE
  mutate(ada = ifelse(stat_name == "irt_pelham_hunts point av", TRUE, ada)) %>% 
  # convert the forst hills / 71st ave station to ada = TRUE for all lines
  mutate(ada = ifelse(stat_name == "ind_queens boulevard_forest hills-71st av", TRUE, ada)) %>% 
  # can get rid of the ada_notes column now
  select(-ada_notes) %>% 
  distinct()
dim(sub.ent.sml)
dim(sub.ent.ada.updt)
sub.ent.sml %>% 
  filter(route_name == "S")
sub.ent.ada.updt %>% 
  filter(route_name == "S")
```

Got rid of a few rows by eliminating the redundant S route, and by removing the ada_notes column. 

Now back to the previous problem of trains being assigned to subway stations that they do not stop at and all the previous problems brought up earlier.

How does the number of stations in the subway entrances/exit dataset per route compare to the expected number (according to wikipedia)?

```{r sub_ent_stat_count, comment= NA}
sub.ent.rt.count <- sub.ent.ada.updt %>% 
  group_by(route_name) %>% 
  count()  
stat.route.join <- sub.ent.rt.count %>% 
  full_join(num.stat.by.rt.wiki, by = "route_name") %>% 
  # W exits in the wiki df, but not in the sub ent/exit df
  filter(route_name != "W")
stat.route.join %>% 
  ggplot(aes(num_stations_norm, n)) +
  # equality line for refence:
  geom_abline(intercept = 0, slope = 1, size = 1, alpha = 0.8) +
  geom_point(size = 2, alpha = 0.8) +
  xlab("Station num by route (wiki)") +
  ylab("Station num by route (actual count)")
stat.route.join %>% 
  filter(num_stations_norm == n)
```

TO EDIT

Nearly all, with the exception of the H Shuttle route, had more subway stations assigned to them than expected. The extra stations could not be accounted for by different service patterns (for example local late-night service for some routes). From exploring the dataset, it seems that the source of the problems were: 


* Station duplicates, or the station name differed based on the route, but all of the routes that stopped at that station were still assigned.
* The dataset being simply outdated - no changes made to account for service changes over the years.
* Separate stations connected by underground tunnels being listed as one station, with all routes servicing both stations. For example, Times Square / 42nd St is linked by a tunnel to the Port Authority / 42nd St stops, but these are distinct stations, served by distinct subway routes. However, all of the subway routes that serve both stations are assigned to both stations.

At this point, the options, as I saw them, were: 

Solution 1: Import a dataset form the NYC Open Data website with updated station coordinates (SOURCE) and try to merge the two datasets 
Problems: Subway station names repeat, would probably have to still do a lot of manual data cleaning and validation to make sure the stations merge as expected. Also, if the subway route information is out of date, likely the ADA-status of stations is also outdated as well (this assumption turns out to be true in the end).

Solution 2: Manually go through route-by-route to make sure that the information is accurate and station duplicates are removed
Problems: Tedious manual work, and likely easy to mess up. Will have to manually add-in new 2nd Ave Q-train stations, along with some others probably.


# Manual data cleaning {.tabset .tabset-fade .tabset-pills}


## Reasoning and Resources

I chose Solution 2 because, from working with other NYC subway-related datasets, I've learned that subway station name formatting tends to be inconsistent between datasets and a number of stations have duplicate names. Going line by line turned out to be less tedious than I expected in the end, because routes in the same primary trunk line tended to have the same issues that needed fixing (removing double stations, for example). Also, most of the subway stations were accurately labeled according to the primary trunk line 3-letter code (irt, ind, and so on), which helped narrow down the list of stations. It's not very pretty, but it got the job done.

These tools helped quite a bit:

NYC Subway Map
Route list

Disclaimer: The subway routes change considerably between normal, rush-hour, late-night, and weekend service. For sanity, I based the route/station assignments on the wikipedia counts for most lines, except for the B, which seems to have been based on weekday rush-hour service patterns for most trains, and on the routes on the MTA website list. I did not include late-night service changes (even though some routes stop at more stations).


## Going by lowest number of stations


Starting slow, with the shuttles:

```{r shuttle_update, comment=NA}
num.stat.by.rt.wiki %>% 
  filter(route_name == "GS")
sub.ent.ada.updt %>% 
  filter(route_name == "GS") %>% 
  arrange(stat_name)
sub.stat.num.updt <- sub.ent.ada.updt %>% 
  filter(!(route_name == "GS" & (str_detect(stat_name, "flushing") | str_detect(stat_name, "lexington"))))
num.stat.by.rt.wiki %>% 
  filter(route_name == "FS")
sub.ent.rt.count %>% 
  filter(route_name == "FS")
sub.stat.num.updt %>% 
  filter(route_name == "FS") %>% 
  arrange(avg_stat_lat)
# remove the ind and irt stations - those are the extras
sub.stat.num.updt <- sub.stat.num.updt %>% 
  filter(!(route_name == "FS" & (str_detect(stat_name, "irt") | str_detect(stat_name, "ind"))))
sub.stat.num.updt %>% 
  filter(route_name == "FS")
sub.stat.num.updt %>% 
  group_by(route_name) %>% 
  count() %>% 
  ungroup() %>% 
  inner_join(num.stat.by.rt.wiki, by = "route_name") %>% 
  filter(n != num_stations_norm) %>% 
  filter(num_stations_norm == min(num_stations_norm))
```


G and Z, both with 21 stations each, are next. I had initially wondered if maybe there are duplicates based on station lat/long pairs, and if I could get away with using the unique coordinates. Unfortunately that did not turn out to be the 


```{r G_and_Z_update, comment=NA}
### G route fix ###
sub.line.tidy %>% 
  filter(route_name == "G")
sub.stat.num.updt %>% 
  filter(route_name == "G") %>% 
  select(avg_stat_lat, avg_stat_long) %>% 
  distinct() %>% 
  nrow()
sub.stat.num.updt.G <- sub.stat.num.updt %>% 
  filter(route_name != "G") %>% 
  bind_rows(
    sub.stat.num.updt %>% 
      filter(route_name == "G" & str_detect(stat_name, "ind") & stat_name != "ind_queens boulevard_23rd st-ely av")
    )
sub.stat.num.updt.G %>% 
  filter(route_name == "G") %>% 
  nrow()

### Z route fix ###
sub.line.tidy %>% 
  filter(route_name == "Z")
sub.stat.num.updt.Z <- sub.stat.num.updt.G %>% 
  filter(route_name != "Z") %>% 
  bind_rows(
    sub.stat.num.updt.G %>% 
      filter(route_name == "Z" & str_detect(stat_name, "bmt") & stat_name != "bmt_broadway_canal st (ul)") %>% 
      # Z train was not included on the list of trains at broadway junction stop in Queens (was A/C/J/L)
      bind_rows(
        sub.stat.num.updt.G %>% 
          filter(str_detect(stat_name, "broadway junction")) %>% 
          mutate(route_name = "Z") %>% 
          distinct()
        ) %>% 
      # Z train was also not listed on Alabama Ave stop in Queens (was J only)
      bind_rows(
        sub.stat.num.updt.G %>% 
          filter(str_detect(stat_name, "alabama")) %>% 
          mutate(route_name = "Z")
      ) %>% 
      # add back in the jamaica center and jfk airport stops that were filtered out
      bind_rows(
        sub.stat.num.updt.G %>% 
          filter(route_name == "Z" & avg_stat_long > -73.82829)
        )
    )
sub.stat.num.updt.Z %>% 
  filter(route_name == "Z") %>% 
  nrow()

## Next fix targets ##
sub.stat.num.updt.Z %>% 
  group_by(route_name) %>% 
  count() %>% 
  ungroup() %>% 
  inner_join(num.stat.by.rt.wiki, by = "route_name") %>% 
  filter(n != num_stations_norm) %>% 
  filter(num_stations_norm == min(num_stations_norm))

# 7 Train, goal: 22
sub.line.tidy %>% 
  filter(route_name == "7")
sub.stat.num.updt.7 <-  sub.stat.num.updt.Z %>%
  filter(route_name != "7") %>% 
  bind_rows(
    sub.stat.num.updt.Z %>% 
      filter(route_name == "7" & str_detect(stat_name, "irt")) %>% 
      # eliminate station copies
      filter(
        # times square extra
        stat_name != "irt_42nd st shuttle_times square" &
        # grand central extra
          stat_name != "irt_42nd st shuttle_grand central" &
          stat_name != "irt_lexington_grand central-42nd st"
          ) %>% 
      mutate(ada = ifelse(stat_name == "irt_flushing_45 rd-court house sq", TRUE, ada))
  )
sub.stat.num.updt.7 %>% 
  filter(route_name == "7") %>% 
  nrow()
# E train, goal: 22
sub.line.tidy %>% 
  filter(route_name == "E")
sub.stat.num.updt.E <- sub.stat.num.updt.7 %>% 
  filter(route_name != "E") %>% 
  bind_rows(
    sub.stat.num.updt.7 %>% 
      filter(route_name == "E" & str_detect(stat_name, "ind")) %>% 
      filter(stat_name != "ind_8 avenue_chambers st") %>% 
      mutate(ada = ifelse(stat_name == "ind_archer av_jamaica-van wyck", TRUE, ada)) %>% 
      bind_rows(
        # add in Briarwood station (a late night station)
        sub.stat.num.updt.7 %>% 
          filter(str_detect(stat_name, "briarwood")) %>% 
          mutate(route_name = "E")
        )
    )

## Next fix targets ##
sub.stat.num.updt.E %>% 
  group_by(route_name) %>% 
  count() %>% 
  ungroup() %>% 
  inner_join(num.stat.by.rt.wiki, by = "route_name") %>% 
  filter(n != num_stations_norm) %>% 
  filter(num_stations_norm == min(num_stations_norm))

# L train, goal: 24
sub.line.tidy %>% 
  filter(route_name == "L")
sub.stat.num.updt.L <-  sub.stat.num.updt.E %>% 
  filter(route_name != "L") %>% 
  bind_rows(
    sub.stat.num.updt.E %>% 
      filter(route_name == "L" & str_detect(stat_name, "bmt")) %>% 
      filter(stat_name != "bmt_broadway_union square") %>% 
      mutate(ada = ifelse(stat_name == "bmt_canarsie_wilson av", TRUE, ada)) %>% 
      # add back in broadway junction
      bind_rows(
        sub.stat.num.updt.E %>% 
          filter(str_detect(stat_name, "broadway junction") & route_name == "L")
        )
    )
sub.stat.num.updt.L %>% 
  filter(route_name == "L") %>% 
  nrow()
## Next fix targets ##
sub.stat.num.updt.L %>% 
  group_by(route_name) %>% 
  count() %>% 
  ungroup() %>% 
  inner_join(num.stat.by.rt.wiki, by = "route_name") %>% 
  filter(n != num_stations_norm) %>% 
  filter(num_stations_norm == min(num_stations_norm))

# B line: target - 37 - will include rush hour stations 
sub.line.tidy %>% 
  filter(route_name == "B")
sub.stat.num.updt.B <- sub.stat.num.updt.L %>% 
  filter(route_name != "B") %>% 
  bind_rows(
    sub.stat.num.updt.L %>% 
      filter(route_name == "B" & (str_detect(stat_name, "bmt") | str_detect(stat_name, "ind"))) %>% 
      # convert non-ada stations to those that are ada = TRUE now
      mutate(
        ada = ifelse((
          stat_name == "bmt_brighton_kings highway" | 
            stat_name == "ind_6 avenue_broadway-lafayette st" | 
            stat_name == "ind_8 avenue_125th st"
          ), TRUE, ada)
        ) %>% 
      # stations to exclude atlantic ave /barclays duplicates 
      # and stops between barclays and brighton where B does not stop
      filter(!(avg_stat_lat > 40.60867 & avg_stat_lat < 40.63508)) %>% 
      filter(!(
        stat_name %in% c(
          "bmt_broadway_34th st", "bmt_brighton_parkside av", 
          "bmt_4 avenue_pacific st", "bmt_brighton_atlantic av", 
          "bmt_brighton_av u", "bmt_brighton_neck rd", 
          "bmt_brighton_beverly rd", "bmt_brighton_cortelyou rd"
          )
        ))
    )
dim(sub.stat.num.updt.B)

## Next fix targets ##
sub.stat.num.updt.B %>% 
  group_by(route_name) %>% 
  count() %>% 
  ungroup() %>% 
  inner_join(num.stat.by.rt.wiki, by = "route_name") %>% 
  filter(n != num_stations_norm) %>%
  filter(route_name != "B") %>% 
  filter(num_stations_norm == min(num_stations_norm))

# 4 train, target is 28 - exclude late night service
sub.stat.num.updt.4 <- sub.stat.num.updt.B %>% 
  filter(route_name != "4") %>% 
  bind_rows(
    sub.stat.num.updt.B %>% 
      filter(route_name == "4" & str_detect(stat_name, "irt")) %>% 
      filter(!(
        stat_name %in% c(
          "irt_flushing_grand central-42nd st", "irt_42nd st shuttle_grand central", 
          "irt_clark_fulton st", "irt_clark_borough hall"
          )
        )) %>% 
      mutate(ada = ifelse(stat_name == "irt_lexington_fulton st", TRUE, ada))
    )
```


## Switch to primary trunk lines

After fixing one or two per trunk line, I figured that the other train routes along that line would have similar problems for most stations (and similar fixes). 

```{r by_trunk_lines, comment=NA}
# J train, goal: 30
sub.stat.num.updt.J <- sub.stat.num.updt.4 %>% 
  filter(route_name != "J") %>% 
  bind_rows(
    sub.stat.num.updt.4 %>% 
      filter(route_name == "J" & str_detect(stat_name, "bmt")) %>%
      filter(stat_name != "bmt_broadway_canal st (ul)") %>% 
      bind_rows(
        sub.stat.num.updt.4 %>% 
        filter(route_name == "J" & avg_stat_long > -73.82829)
      ) %>% 
      bind_rows(
        sub.stat.num.updt.4 %>% 
              filter(str_detect(stat_name, "broadway junction") & route_name == "J")
      ) %>% 
      mutate(ada = ifelse(stat_name == "bmt_nassau_fulton st", TRUE, ada))
    )

sub.stat.num.updt.J %>% 
  group_by(route_name) %>% 
  count() %>% 
  ungroup() %>% 
  inner_join(num.stat.by.rt.wiki, by = "route_name") %>% 
  filter(n != num_stations_norm) %>%
  filter(route_name != "B")

# route A, goal: 44 stations
sub.stat.num.updt.A <- sub.stat.num.updt.J %>% 
  filter(route_name != "A") %>% 
  bind_rows(
    sub.stat.num.updt.J %>% 
      filter(route_name == "A" & str_detect(stat_name, "ind")) %>%
      filter(!(
        stat_name %in% c(
          "ind_8 avenue_world trade center", "ind_8 avenue_broadway-nassau", 
          "ind_fulton_franklin av", "ind_fulton_kingston-throop",
          "ind_fulton_ralph av", "ind_fulton_rockaway av",
          "ind_fulton_liberty av", "ind_fulton_van siclen av", 
          "ind_fulton_shepherd av"
          )
        )) %>% 
      bind_rows(
        sub.stat.num.updt.J %>% 
          filter(str_detect(stat_name, "fulton st") & route_name == "4") %>% 
          mutate(route_name = "A")
      ) %>% 
      mutate(ada = ifelse(stat_name %in% c("ind_8 avenue_125th st", "ind_rockaway_far rockaway-mott av", "ind_rockaway_aqueduct racetrack", "ind_fulton_jay st - borough hall", "ind_fulton_utica av", "ind_liberty_lefferts blvd"), TRUE, ada)) %>% 
      bind_rows(
        sub.stat.num.updt.J %>% 
          filter(route_name == "H" & !(str_detect(stat_name, "broad channel"))) %>% 
          mutate(route_name = "A")
      )
    )
nrow(sub.stat.num.updt.A)

sub.stat.num.updt.A %>% 
  group_by(route_name) %>% 
  count() %>% 
  ungroup() %>% 
  inner_join(num.stat.by.rt.wiki, by = "route_name") %>% 
  filter(n != num_stations_norm) %>%
  filter(route_name != "B")
# C next, goal: 40 stations
sub.stat.num.updt.C <- sub.stat.num.updt.A %>% 
  filter(route_name != "C") %>% 
  bind_rows(
    sub.stat.num.updt.A %>% 
      filter(route_name == "C" & str_detect(stat_name, "ind")) %>% 
      filter(!(stat_name %in% c("ind_8 avenue_broadway-nassau", "ind_8 avenue_world trade center"))) %>% 
      bind_rows(
            sub.stat.num.updt.A %>% 
              filter(str_detect(stat_name, "fulton st") & route_name == "A") %>% 
              mutate(route_name = "C")
        ) %>%
      mutate(ada = ifelse(stat_name %in% c("ind_8 avenue_125th st", "ind_fulton_jay st - borough hall", "ind_fulton_utica av"), TRUE, ada))
)
sub.stat.num.updt.C %>% 
  group_by(route_name) %>% 
  count() %>% 
  ungroup() %>% 
  inner_join(num.stat.by.rt.wiki, by = "route_name") %>% 
  filter(n != num_stations_norm) %>%
  filter(route_name != "B")
# route 5, goal: 45 
sub.stat.num.updt.5 <- sub.stat.num.updt.C %>% 
  filter(route_name != "5") %>% 
  bind_rows(
    sub.stat.num.updt.C %>% 
      filter(route_name == "5" & str_detect(stat_name, "irt")) %>% 
      filter(!(
        stat_name %in% c(
          "irt_clark_borough hall", "irt_clark_fulton st", 
          "irt_flushing_grand central-42nd st", "irt_42nd st shuttle_grand central", 
          "irt_white plains road_wakefield-241st st"
          )
        )) %>%
      mutate(ada = ifelse(
        stat_name %in% c("irt_lexington_fulton st", "irt_white plains road_east 180th st", "irt_white plains road_gun hill rd"), TRUE, ada
        ))
    )
sub.stat.num.updt.5 %>% 
  group_by(route_name) %>% 
  count() %>% 
  ungroup() %>% 
  inner_join(num.stat.by.rt.wiki, by = "route_name") %>% 
  filter(n != num_stations_norm) %>%
  filter(route_name != "B")

# Next: route 6, goal = 38
sub.stat.num.updt.6 <- sub.stat.num.updt.5 %>% 
  filter(route_name != "6") %>% 
  bind_rows(
    sub.stat.num.updt.5 %>% 
      filter(route_name == "6" & str_detect(stat_name, "irt")) %>% 
      filter(!(stat_name %in% c("irt_flushing_grand central-42nd st", "irt_42nd st shuttle_grand central"))) %>% 
      mutate(ada = ifelse(stat_name %in% c("irt_lexington_bleecker st"), TRUE, ada))
    )
sub.stat.num.updt.6 %>% 
  group_by(route_name) %>% 
  count() %>% 
  ungroup() %>% 
  inner_join(num.stat.by.rt.wiki, by = "route_name") %>% 
  filter(n != num_stations_norm) %>%
  filter(route_name != "B")
# Next: route D, goal: 36
sub.stat.num.updt.D <- sub.stat.num.updt.6 %>% 
  filter(route_name != "D") %>% 
  bind_rows(
    sub.stat.num.updt.6 %>% 
      filter(route_name == "D" & (str_detect(stat_name, "ind") | str_detect(stat_name, "bmt"))) %>% 
      filter(!(
        stat_name %in% c(
          "bmt_broadway_34th st", "bmt_4 avenue_pacific st", 
          "bmt_brighton_atlantic av", "bmt_sea beach_new utrecht av", 
          "bmt_brighton_stillwell av")
        )) %>% 
      bind_rows(
        sub.stat.num.updt.6 %>% 
          filter(str_detect(stat_name, "4 avenue_36")) %>% 
          mutate(route_name = "D") %>% 
          distinct()
        ) %>% 
      mutate(ada = ifelse(
        stat_name %in% c("ind_8 avenue_125th st", "ind_6 avenue_broadway-lafayette st", "bmt_west end_bay parkway"), TRUE, ada)
        )
    )

sub.stat.num.updt.D %>% 
  group_by(route_name) %>% 
  count() %>% 
  ungroup() %>% 
  inner_join(num.stat.by.rt.wiki, by = "route_name") %>% 
  filter(n != num_stations_norm) %>%
  filter(route_name != "B")

# Next: route F, goal: 45
sub.stat.num.updt.F <- sub.stat.num.updt.D %>% 
  filter(route_name != "F") %>% 
  bind_rows(
    sub.stat.num.updt.D %>% 
      filter(route_name == "F" & (str_detect(stat_name, "ind") | str_detect(stat_name, "bmt"))) %>% 
      filter(!(
        stat_name %in% c(
          "bmt_broadway_34th st", "bmt_canarsie_6th av", 
          "bmt_nassau_essex st", "bmt_broadway_lawrence st", 
          "bmt_4 avenue_9th st", "bmt_brighton_stillwell av", 
          "bmt_brighton_west 8th st"
          )
        )) %>% 
      mutate(ada = ifelse(stat_name %in% c("ind_6 avenue_broadway-lafayette st", "ind_fulton_jay st - borough hall"), TRUE, ada))
    )
nrow(sub.stat.num.updt.F %>% filter(route_name == "F"))
sub.stat.num.updt.F %>% 
  group_by(route_name) %>% 
  count() %>% 
  ungroup() %>% 
  inner_join(num.stat.by.rt.wiki, by = "route_name") %>% 
  filter(n != num_stations_norm) %>%
  filter(route_name != "B")
# Next: route M, goal: 36
sub.stat.num.updt.M <- sub.stat.num.updt.F %>% 
  filter(route_name != "M") %>% 
  bind_rows(
    sub.stat.num.updt.F %>% 
      filter(route_name == "M" & (str_detect(stat_name, "ind") | str_detect(stat_name, "bmt"))) %>% 
      filter(!(stat_name %in% c("bmt_broadway_34th st", "bmt_canarsie_6th av", "bmt_nassau_essex st"))) %>% 
      mutate(ada = ifelse(stat_name %in% c("ind_6 avenue_broadway-lafayette st"), TRUE, ada))
    )
sub.stat.num.updt.M %>% 
  group_by(route_name) %>% 
  count() %>% 
  ungroup() %>% 
  inner_join(num.stat.by.rt.wiki, by = "route_name") %>% 
  filter(n != num_stations_norm) %>%
  filter(route_name != "B")
# Next: route 1, goal: 38
sub.stat.num.updt.1 <- sub.stat.num.updt.M %>% 
  filter(route_name != "1") %>% 
  bind_rows(
    sub.stat.num.updt.M %>% 
      filter(route_name == "1" & str_detect(stat_name, "irt")) %>%
      filter(!(stat_name %in% c("irt_42nd st shuttle_times square", "irt_clark_park place"))) %>% 
      # add in the re-opened WTC Cortlandt station (coord from wikipedia)
      bind_rows(
        tibble(
          stat_name = "irt_broadway-7th ave_wtc cortlandt", ada = TRUE, 
          avg_stat_lat = 40.7115, avg_stat_long = -74.012, route_name = "1")
        ) %>% 
      mutate(
        ada = ifelse(
          stat_name %in% c(
            "irt_broadway-7th ave_dyckman st", "irt_broadway-7th ave_168th st"
            ), 
          TRUE, ada))
    )
sub.stat.num.updt.1 %>% 
  group_by(route_name) %>% 
  count() %>% 
  ungroup() %>% 
  inner_join(num.stat.by.rt.wiki, by = "route_name") %>% 
  filter(n != num_stations_norm) %>%
  filter(route_name != "B")
# Next: route 2, goal: 49 or 52?
sub.stat.num.updt.2 <- sub.stat.num.updt.1 %>% 
  filter(route_name != "2") %>% 
  bind_rows(
    sub.stat.num.updt.1 %>% 
      filter(route_name == "2" & str_detect(stat_name, "irt")) %>% 
      filter(!(
        stat_name %in% c(
          "irt_42nd st shuttle_times square", "irt_lexington_fulton st",
          "irt_lexington_borough hall"
          )
        )) %>% 
      mutate(
        ada = ifelse(stat_name %in% c(
          "irt_white plains road_gun hill rd", "irt_white plains road_east 180th st",
          "irt_clark_fulton st"
          ), TRUE, ada)
        )
    )
sub.stat.num.updt.2 %>% 
  group_by(route_name) %>% 
  count() %>% 
  ungroup() %>% 
  inner_join(num.stat.by.rt.wiki, by = "route_name") %>% 
  filter(n != num_stations_norm) %>%
  filter(route_name != "B")

#Next: route 3, goal: 34
sub.stat.num.updt.3 <- sub.stat.num.updt.2 %>% 
  filter(route_name != "3") %>% 
  bind_rows(
    sub.stat.num.updt.2 %>% 
      filter(route_name == "3" & str_detect(stat_name, "irt")) %>% 
      filter(!(stat_name %in% c(
        "irt_42nd st shuttle_times square", "irt_lexington_fulton st", "irt_lexington_borough hall"
        ))) %>%
      mutate(ada = ifelse(stat_name %in% c("irt_clark_fulton st"), TRUE, ada))
    )
sub.stat.num.updt.3 %>% 
  group_by(route_name) %>% 
  count() %>% 
  ungroup() %>% 
  inner_join(num.stat.by.rt.wiki, by = "route_name") %>% 
  filter(n != num_stations_norm) %>%
  filter(route_name != "B")
# What I've been dreading, R goal = 45
sub.stat.num.updt.R <- sub.stat.num.updt.3 %>% 
  filter(route_name != "R") %>% 
  bind_rows(
    sub.stat.num.updt.3 %>% 
      filter(route_name == "R" & (str_detect(stat_name, "bmt") | str_detect(stat_name, "ind"))) %>% 
      filter(!(stat_name %in% c(
        "ind_6 avenue_smith-9th st", "bmt_4 avenue_pacific st", 
        "bmt_brighton_atlantic av", "ind_fulton_jay st - borough hall", 
        "bmt_nassau_canal st", "bmt_canarsie_union square", "ind_6 avenue_34th st", "ind_8 avenue_42nd st"
        ))) %>% 
      mutate(ada = ifelse(stat_name %in% c("bmt_broadway_lawrence st", "bmt_broadway_cortlandt st"), TRUE, ada))
    )
sub.stat.num.updt.R %>% 
  group_by(route_name) %>% 
  count() %>% 
  ungroup() %>% 
  inner_join(num.stat.by.rt.wiki, by = "route_name") %>% 
  filter(n != num_stations_norm) %>%
  filter(route_name != "B")
# Next: route N, num stations - 32
sub.stat.num.updt.N <- sub.stat.num.updt.R %>% 
  filter(route_name != "N") %>% 
  bind_rows(
    sub.stat.num.updt.R %>% 
      filter(route_name == "N" & str_detect(stat_name, "bmt")) %>% 
      filter(!(stat_name %in% c(
        "bmt_brighton_stillwell av", "bmt_west end_62nd st", 
        "bmt_brighton_atlantic av", "bmt_4 avenue_pacific st", 
        "bmt_nassau_canal st", "bmt_canarsie_union square"
        ))) %>% 
      bind_rows(
        sub.stat.num.updt.R %>% filter(route_name == "N" & str_detect(stat_name, "queensboro"))
      )
    )
sub.stat.num.updt.N %>% 
  group_by(route_name) %>% 
  count() %>% 
  ungroup() %>% 
  inner_join(num.stat.by.rt.wiki, by = "route_name") %>% 
  filter(n != num_stations_norm) %>%
  filter(route_name != "B")

num.stat.by.rt.wiki %>% 
  filter(route_name == "W")

sub.stat.num.updt.W <- sub.stat.num.updt.N %>% 
  bind_rows(
    sub.stat.num.updt.N %>% 
      filter(route_name == "N" & avg_stat_lat > 40.68367) %>% 
      bind_rows(
        sub.stat.num.updt.N %>% 
          filter(route_name == "R") %>% 
          filter(avg_stat_lat > 40.69410 & avg_stat_lat < 40.71952)
        ) %>% 
      mutate(route_name = "W")
    )
sub.stat.num.updt.W %>% 
  group_by(route_name) %>% 
  count() %>% 
  ungroup() %>% 
  inner_join(num.stat.by.rt.wiki, by = "route_name") %>% 
  filter(n != num_stations_norm) %>%
  filter(route_name != "B")
# last route: Q, with 29 stations

sub.stat.num.updt.final <- sub.stat.num.updt.W %>% 
  filter(route_name != "Q") %>% 
  bind_rows(
    sub.stat.num.updt.W %>% 
      filter(route_name == "Q" & !str_detect(stat_name, "astoria") & str_detect(stat_name, "bmt")) %>%
      bind_rows(
        tibble(
          stat_name = c("ind_2 avenue_72nd st", "ind_2 avenue_86th st", "ind_2 avenue_96th st"), 
          ada = rep(TRUE, 3), 
          avg_stat_lat = c(40.768889, 40.777861, 40.7841), 
          avg_stat_long = c(-73.958333, -73.95175, -73.9472), 
          route_name = rep("Q", 3)
          )
        ) %>% 
      bind_rows(
        sub.stat.num.updt.W %>% 
          filter(stat_name == "ind_63rd street_lexington av") %>% 
          mutate(route_name = "Q")
      ) %>% 
      filter(!(stat_name %in% c(
        "bmt_broadway_5th av", "bmt_broadway_lexington av", 
        "bmt_broadway_49th st", "bmt_canarsie_union square", 
        "bmt_nassau_canal st", "bmt_4 avenue_pacific st", 
        "bmt_brighton_atlantic av", "bmt_coney island_stillwell av", 
        "bmt_coney island_west 8th st"
        ))) %>%
      mutate(ada = ifelse(stat_name %in% c("bmt_brighton_av h", "bmt_brighton_kings highway"), TRUE, ada))
    )
sub.stat.num.updt.final %>% 
  group_by(route_name) %>% 
  count() %>% 
  ungroup() %>% 
  inner_join(num.stat.by.rt.wiki, by = "route_name") %>% 
  filter(n != num_stations_norm) %>%
  filter(route_name != "B")
nrow(sub.stat.num.updt.final)
```

At last! The subway station route counts match.


# Analysis and Visualization

```{r comment=NA}
sub.cln.sf <- st_as_sf(sub.stat.num.updt.final, coords = c("avg_stat_long", "avg_stat_lat"), crs = 4326)
sub.sf.nyc.crs <- st_transform(sub.cln.sf, crs = st_crs(nyc.census.4boro))
nyc.neigh.4boro %>% 
  ggplot() +
  geom_sf(fill = NA) +
  geom_sf(data = sub.sf.nyc.crs, size = 1, color = "#D55E00")
```


```{r}
stat.by.route <- sub.stat.num.updt.final %>% 
  group_by(route_name) %>% 
  summarize(
    total_stat = n(),
    num_ada = sum(ada),
    per_ada = num_ada * 100 / total_stat
  ) %>% 
  mutate(
    rt_mod = ifelse(
      route_name == "GS" | route_name == "FS" | route_name == "H",
      "S",
      route_name
      )
    ) %>% 
  left_join(sub.line.tidy, by = c("rt_mod" = "route_name")) %>% 
  arrange(primary_trunk_line, route_name) 
stat.by.route$rt_order <- factor(stat.by.route$route_name, levels = stat.by.route$route_name)

subway.by.line <- subway.by.line %>% 
  arrange(primary_trunk_line)

stat.by.route %>% 
  ggplot(aes(rt_order, total_stat, fill = primary_trunk_line)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = subway.by.line$hexadecimal, name = "Line") +
  ylab("Total Number of Stations") +
  xlab("Subway Route")
stat.by.route %>% 
  ggplot(aes(rt_order, num_ada, fill = primary_trunk_line)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = subway.by.line$hexadecimal, name = "Line") +
  ylab("Number of ADA Stations") +
  xlab("Subway Route")
stat.by.route %>% 
  ggplot(aes(rt_order, per_ada, fill = primary_trunk_line)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = subway.by.line$hexadecimal, name = "Line") +
  ylab("Percent of Stations that are ADA") +
  xlab("Subway Route")

stat.by.route <- stat.by.route %>% 
  arrange(total_stat) %>% 
  mutate(total_stat_order = factor(route_name, levels = route_name))
 
stat.by.route %>% 
  ggplot(aes(total_stat_order, total_stat)) +
  geom_segment(aes(x = total_stat_order, xend = total_stat_order, y = num_ada, yend = total_stat), size = 1, alpha= 0.5, color = "#56B4E9") +
  geom_point(size = 3, color = "#0072B2") +
  geom_point(aes(total_stat_order, num_ada), size = 3, color = "#56B4E9") +
  xlab("Route Name") +
  coord_flip()

stat.by.route %>% 
  ggplot(aes(total_stat, num_ada, color = primary_trunk_line)) +
  geom_abline(slope = 1, intercept = 0, alpha = 0.5, size = 1.5) +
  geom_point(size = 3) +
  scale_color_manual(values = subway.by.line$hexadecimal, name = "Line") +
  xlab("Total Number of Stations") +
  ylab("Number of ADA Stations") +
  theme_minimal()
stat.by.route %>% 
  ggplot(aes(total_stat, per_ada, color = primary_trunk_line)) +
  geom_point(size = 3) +
  scale_color_manual(values = subway.by.line$hexadecimal, name = "Line") +
  xlab("Total Number of Stations") +
  ylab("Percent of Stations that are ADA") +
  theme_minimal()
stat.by.route %>% 
  ggplot(aes(total_stat, per_ada, color = primary_trunk_line, label = route_name)) +
  geom_point(size = 3) +
  scale_color_manual(values = subway.by.line$hexadecimal, name = "Line") +
  geom_text(hjust = 0, vjust = 0, check_overlap = TRUE, nudge_y = 1.5) +
  xlab("Total Number of Stations") +
  ylab("Percent of Stations that are ADA") +
  theme_minimal()
```


```{r boro_plots, comment=NA}
sub.boro <- st_join(sub.sf.nyc.crs, nyc.census.4boro)
sub.boro.nogeo <- st_set_geometry(sub.boro, NULL) %>% 
  as_tibble() %>% 
  select(stat_name:route_name, boroname:boroct2010, ntaname, shape_area)
nyc.census.4boro %>% filter(str_detect(ntaname, "park") | str_detect(ntaname, "Airport")) %>% ggplot() +geom_sf()
nyc.census.4boro %>% 
  filter(!(str_detect(ntaname, "park") | str_detect(ntaname, "Airport"))) %>% 
  ggplot(aes(shape_area)) +
  geom_histogram()
tract.cent <- st_centroid(nyc.census.4boro)

sub.boro.nogeo

boro.stat.count <- sub.boro.nogeo %>%
  group_by(boroname) %>% 
  summarize(
    tot_stat = n(),
    ada_stat = sum(ada),
    not_ada = tot_stat - ada_stat,
    ada_percent = ada_stat * 100 / tot_stat
    )
boro.stat.count %>% 
  select(-c(tot_stat, ada_percent)) %>% 
  gather("stat_type", "num_stat", ada_stat:not_ada) %>% 
  ggplot(aes(boroname, num_stat, fill = stat_type)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_tableau()
boro.stat.count %>% 
  ggplot(aes(boroname, ada_percent, fill = boroname)) + 
  geom_bar(stat= "identity") +
  scale_fill_tableau()
neigh.stat.count <- sub.boro.nogeo %>% 
  group_by(boroname, ntaname) %>% 
  summarize(
    tot_stat = n(),
    ada_stat = sum(ada),
    ada_percent = ada_stat * 100 / tot_stat
    )
neigh.stat.count %>% 
  ggplot(aes(x = boroname, y = ada_percent, color = boroname)) +
  geom_jitter(size = 2, alpha = 0.8, width = 0.25) +
  ylab("Percent ADA by Neighborhood") +
  xlab("Borough Name") +
  scale_color_tableau()
```




```{r}
nyc.neigh.stat.count <- st_join(sub.sf.nyc.crs, nyc.neigh.4boro) %>% 
 st_set_geometry(NULL) %>% 
  group_by(boroname, NTAName) %>% 
  summarize(
    tot_stat = n(),
    ada_stat = sum(ada),
    percent_ada = ada_stat * 100 / tot_stat
  ) %>% 
  ungroup()
glimpse(nyc.neigh.stat.count)
nyc.neigh.stat.count %>% 
  ggplot(aes(boroname, tot_stat, color = boroname)) +
  geom_jitter(size = 2, alpha = 0.8, width = 0.25) +
  scale_color_tableau()
data_summary <- function(x) {
   m <- mean(x)
   ymin <- ifelse(m - sd(x) > 0, m - sd(x), 0)
   ymax <- m + sd(x)
   return(c(y=m,ymin=ymin,ymax=ymax))
}
nyc.neigh.stat.count %>% 
  ggplot(aes(boroname, tot_stat, color = boroname, fill = boroname)) +
  geom_violin() +
  stat_summary(fun.data = data_summary, color = "black", alpha = 0.8) +
  scale_color_tableau() +
  scale_fill_tableau() +
  xlab("Borough") +
  ylab("Subway Stations per Neighborhood")
nyc.neigh.stat.count %>% 
  ggplot(aes(boroname, ada_stat, color = boroname, fill = boroname)) +
  geom_violin() +
  stat_summary(fun.data = data_summary, color = "black", alpha = 0.8) +
  scale_color_tableau() +
  scale_fill_tableau() +
  xlab("Borough") +
  ylab("Subway Stations per Neighborhood")

nyc.neigh.4boro.count <- nyc.neigh.4boro %>% 
  full_join(
    nyc.neigh.stat.count %>% 
      select(-boroname),
    by = "NTAName"
    )
nyc.neigh.4boro.count %>% 
  ggplot() +
  geom_sf(aes(fill = tot_stat)) +
  scale_fill_viridis_c()
nyc.neigh.count.prep <- nyc.neigh.4boro.count %>% 
  mutate(
    color_group = ifelse(
      str_detect(NTAName, "park"), "Park", ifelse(
        str_detect(NTAName, "Airport"), "Airport", ifelse(
          !(str_detect(NTAName, "park") | str_detect(NTAName, "Airport")) & is.na(tot_stat), "No stations", ifelse(
            !(str_detect(NTAName, "park") | str_detect(NTAName, "Airport")) & tot_stat > 0 & ada_stat < 1, "No accessible stations", ifelse(
              !(str_detect(NTAName, "park") | str_detect(NTAName, "Airport")) & tot_stat > 0 & ada_stat > 0, "At least one accessible station", "Don't know"
              )
            )
          )
        )
      )
    )
table(nyc.neigh.count.prep$color_group)
nyc.neigh.count.prep %>% 
  ggplot() +
  geom_sf(aes(fill = color_group), color = "#BFBFBF") +
  scale_fill_manual(values = c("grey30", "#0072B2", "#E69F00", "#999999", "#bae4b3")) +
  geom_sf(data = sub.sf.nyc.crs, color = "#BFBFBF", fill = "black", size = 1, pch = 21)
nyc.neigh.count.prep %>% 
  ggplot() +
  geom_sf(aes(fill = tot_stat), color = "#BFBFBF") +
  scale_fill_viridis_c(option = "D")
nyc.neigh.count.prep %>% 
  ggplot() +
  geom_sf(aes(fill = ada_stat), color = "#BFBFBF") +
  scale_fill_viridis_c(option = "D")
nyc.neigh.count.prep$ada_per_breaks <- cut(nyc.neigh.count.prep$percent_ada, breaks = seq(0, 100, 20))
nyc.neigh.count.prep %>% 
  ggplot() +
  geom_sf(aes(fill = ada_per_breaks), color = "#BFBFBF") +
  scale_fill_manual(values = c("#c7e9b4", "#7fcdbb", "#41b6c4", "#2c7fb8", "#253494"), na.value = "gray50")
summary(nyc.neigh.count.prep$percent_ada)
```



```{r census_tract_buffer, comment=NA}
tract.cent <- st_centroid(nyc.census.4boro)
nyc.census.4boro %>% 
  ggplot() +
  geom_sf(color = "#BFBFBF") +
  geom_sf(data = tract.cent, size = 1, color = "#4E79A7")
# half-mile buffer
tract.cent.halfmi.buff <- st_buffer(tract.cent, dist = 2640)
nyc.census.4boro %>% 
  ggplot() +
  geom_sf(color = "#BFBFBF") +
  geom_sf(data = tract.cent.halfmi.buff, alpha = 0.2, color = "#F28E2B") +
  geom_sf(data = tract.cent, size = 1, color = "#4E79A7")
#example
nyc.census.4boro %>% 
  ggplot() +
  geom_sf(color = "#BFBFBF") +
  geom_sf(data = tract.cent.halfmi.buff %>% filter(BoroCT2010 == 1009800 | BoroCT2010 == 1018400 ), alpha = 0.8, color = "#F28E2B", fill = "#F28E2B") +
  geom_sf(data = sub.sf.nyc.crs, color = "black", size = 1)



sub.buffer.join <- st_join(sub.sf.nyc.crs, tract.cent.halfmi.buff) %>% 
  st_set_geometry(NULL)

sub.buffer.join %>% 
  filter(BoroCT2010 == 1018400)

nyc.map.4boro.test <- nyc.census.4boro %>% 
  full_join(
    sub.buffer.join %>% 
      group_by(BoroCT2010) %>% 
      summarize(
        tot_stat = n(),
        ada_stat = sum(ada)
      ) %>% 
      ungroup(),
    by = "BoroCT2010"
    )
length(unique(sub.buffer.join$BoroCT2010))
length(unique(nyc.census.4boro$BoroCT2010))
nyc.map.4boro.test %>% 
  filter(BoroCT2010 == 1009800 | BoroCT2010 == 1018400)

nyc.map.4boro.test %>% 
  ggplot() +
  geom_sf(aes(fill = tot_stat)) +
  scale_fill_viridis_c(option = "A") +
  geom_sf(data = sub.sf.nyc.crs, color = "white", size = 1)
nyc.map.4boro.test %>% 
    mutate(
    color_group = ifelse(
      str_detect(NTAName, "park"), "Park", ifelse(
        str_detect(NTAName, "Airport"), "Airport", ifelse(
          !(str_detect(NTAName, "park") | str_detect(NTAName, "Airport")) & is.na(tot_stat), "No stations", ifelse(
            !(str_detect(NTAName, "park") | str_detect(NTAName, "Airport")) & tot_stat > 0 & ada_stat < 1, "No accessible stations", ifelse(
              !(str_detect(NTAName, "park") | str_detect(NTAName, "Airport")) & tot_stat > 0 & ada_stat > 0, "At least one accessible station", "Don't know"
              )
            )
          )
        )
      )
    ) %>% 
  ggplot() +
  geom_sf(aes(fill = color_group)) +
  scale_fill_manual(values = c("grey30", "#0072B2", "#E69F00", "#999999", "#bae4b3")) +
  #geom_sf(data = sub.sf.nyc.crs, color = "#BFBFBF", fill = "black", size = 1, pch = 21)
  geom_sf(data = sub.sf.nyc.crs, color = "#BFBFBF", size = 1)

nyc.map.4boro.test %>% 
  mutate(ada_stat = ifelse(ada_stat == 0, NA, ada_stat)) %>% 
  ggplot() +
  geom_sf(aes(fill = ada_stat)) +
  scale_fill_viridis_c(option = "A") +
  geom_sf(data = sub.sf.nyc.crs, color = "white", size = 1)


### separate the spatial join by borough ###

sub.sf.nyc.crs.boro <- sub.sf.nyc.crs %>% 
  inner_join(
    sub.boro %>% 
      st_set_geometry(NULL) %>% 
      as_tibble() %>% 
      select(stat_name, boroname) %>% 
      distinct(),
    by = "stat_name"
  )

sub.join.borolim <- sub.sf.nyc.crs.boro %>% 
  # manhattan
  filter(boroname == "manhattan") %>% 
  st_join(
    tract.cent.halfmi.buff %>% 
      filter(boroname == "manhattan")
    ) %>% 
  st_set_geometry(NULL) %>% 
  bind_rows(
    # bronx
    sub.sf.nyc.crs.boro %>% 
      filter(boroname == "bronx") %>% 
      st_join(
        tract.cent.halfmi.buff %>% 
          filter(boroname == "bronx")
        ) %>% 
      st_set_geometry(NULL)
    ) %>% 
  bind_rows(
    # brooklyn and queens together
    sub.sf.nyc.crs.boro %>% 
      filter(boroname == "brooklyn" | boroname == "queens") %>% 
      st_join(
        tract.cent.halfmi.buff %>% 
          filter(boroname == "brooklyn" | boroname == "queens")
        ) %>% 
      st_set_geometry(NULL)
    )

nyc.map.4boro.buff.join <- nyc.map.4boro %>% 
  full_join(
    sub.join.borolim %>% 
      group_by(BoroCT2010) %>% 
      summarize(
        tot_stat = n(),
        ada_stat = sum(ada)
      ) %>% 
      ungroup(),
    by = "BoroCT2010"
    )


nyc.map.4boro.buff.join %>% 
  ggplot() +
  geom_sf(aes(fill = tot_stat)) +
  scale_fill_viridis_c(option = "A") +
  geom_sf(data = sub.sf.nyc.crs, color = "white", size = 1)
nyc.map.4boro.buff.join %>% 
    mutate(
    color_group = ifelse(
      str_detect(NTAName, "park"), "Park", ifelse(
        str_detect(NTAName, "Airport"), "Airport", ifelse(
          !(str_detect(NTAName, "park") | str_detect(NTAName, "Airport")) & is.na(tot_stat), "No stations", ifelse(
            !(str_detect(NTAName, "park") | str_detect(NTAName, "Airport")) & tot_stat > 0 & ada_stat < 1, "No accessible stations", ifelse(
              !(str_detect(NTAName, "park") | str_detect(NTAName, "Airport")) & tot_stat > 0 & ada_stat > 0, "At least one accessible station", "Don't know"
              )
            )
          )
        )
      )
    ) %>% 
  ggplot() +
  geom_sf(aes(fill = color_group)) +
  scale_fill_manual(values = c("grey30", "#0072B2", "#E69F00", "#999999", "#bae4b3")) +
  #geom_sf(data = sub.sf.nyc.crs, color = "#BFBFBF", fill = "black", size = 1, pch = 21)
  geom_sf(data = sub.sf.nyc.crs, color = "#BFBFBF", size = 1)

nyc.map.4boro.buff.join %>% 
  mutate(ada_stat = ifelse(ada_stat == 0, NA, ada_stat)) %>% 
  ggplot() +
  geom_sf(aes(fill = ada_stat)) +
  scale_fill_viridis_c(option = "A") +
  geom_sf(data = sub.sf.nyc.crs, color = "white", size = 1)

```


# Session Info

```{r session_info, comment=NA}
sessionInfo()
```

